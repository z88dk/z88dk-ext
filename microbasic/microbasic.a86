
; Converted with 'to86.awk', part of the z88dk Developement Kit
; -------------------------------------------------------------
;
; to build:   nasm -O2 -o mb.com microbasic.a86
; or (for extra functionalities): nasm -O2 -DEXTRA -o mb.com mb86.asm

	;;UPPERCASE  ; force 'nasm' to produce uppercase global object names

;
;
;ADD-ONS for TINY MS-DOS VERSION
;-------------------------------
;
;VIDEO nnnn  calls int10, I.E. VIDEO 19 sets 320x200x256 graphics mode
;	I.E.:
;	      VIDEO 3 -> CLS (INIT TEXT MODE)
;	      VIDEO 4370 -> set 80 columns mode
;	      VIDEO 256 to hide cursor (VIDEO 3 SHOWS IT AGAIN)
;	      VIDEO 1280 ... VIDEO 1283 ... change current text page
;	      
;	      VIDEO 18 SETS 640x480x16 MODE
;	      VIDEO 19 SETS 320x200x256 MODE
;	      
;PLOT x,y,c  plots a pixel with the given colour
;EXIT nn     exits to DOS, passing the given return code
;INKEY v     gets keyboard state and puts ASCII value in integer variable
;EXEC        executes an external DOS command (shell is more useful than "USR", nowadays)
;
;
;Packaging (to merge a BASIC program with MB86 into a single .COM file):
;
;	- copy mb.com autorun
;	
;	- debug autorun
;	 	e 107 90 90
;		w
;		q
;	
;	- copy /b autorun+program.bas program.com

;;section code

;TITLE	MICRO BASIC
;**************************************************************
;*                       MICRO-BASIC                          *
;*------------------------------------------------------------*
;*   A SMALL INTEGER BASIC INTERPRETER FOR THE 8080/8085/Z80  *
;*                                D.F. DUNFIELD  JAN 25/1983  *
;*------------------------------------------------------------*
;*                      BASIC COMMANDS                        *
;*                                                            *
;*  CLEAR,    DATA,     DIM,      END,      EXIT,     FOR,    *
;*  GOSUB,    GOSUB(N), GOTO,     GOTO(N),  IF/THEN,  INPUT,  *
;*  LET,      LIF/THEN, LIST,     LOAD,     NEW,      NEXT,   *
;*  ORDER,    PLOT,     PRINT,    READ,     REM,      RETURN, *
;*  RUN,      SAVE,     SIZE,     STOP,     USR,      <EDIT>  *
;*------------------------------------------------------------*
;*                     BASIC OPERATORS                        *
;*                                                            *
;* NUMERIC:     + - * % / \ & | ; ( ) < = > == -= <= >=       *
;* CHARACTER:   + = == -=                                     *
;* OTHER:       : # $ @ ? [ ] ( )                             *
;*------------------------------------------------------------*
;*                      BASIC VARIABLES                       *
;*                                                            *
;*     A - Z ......... 16 BIT SIMPLE INTEGER VARIABLES.       *
;*     A$ - Z$ ....... SIMPLE CHARACTER VARIABLES. < 36 CHARS *
;*     A[N] - Z[N] ... 16 BIT INTEGER ARRAYS.                 *
;*     @[N] .......... PSEUDO MEMORY REFERENCE ARRAY.         *
;*     @[N]$ ......... NUMERIC TO CHARACTER CONVERSION.(CHR$) *
;*     ? ............. PSEUDO RANDOM NUMBER GENERATOR.        *
;*------------------------------------------------------------*
;*                        MEMORY MAP                          *
;*                                                            *
;*    0000-03FF     1K SYSTEM MONITOR (IN ROM).               *
;*    0400-0FFF     3K BASIC INTERPRETER (IN ROM).            *
;*    1000-13FF     1K MEMORY MAPPED 64*16 VIDEO DISPLAY      *

; *THIS HAS TO BE RELOCATED (BUFF constant)*
;*    1400-15FF     0.5K POINTERS, STACKS, BUFFERS.           *
;*    1600-19FF     1K VARIABLES AND POINTERS.                *
;*    1A00-FFFF     PROGRAM AND ARRAY STORAGE.                *
;**************************************************************
;PAGE
;*
;**************************************************************
;*                   CONSTANTS AND EQUATES
;**************************************************************
;*
;* MONITOR ROUTINES
;*
;DEFC IN     =  $23F 
;DEFC OUTCH  =  16
;DEFC CTRLC  =  $27E 
;EXIT   EQU   $0
;DEFC GETR   =  $2EB 
;DEFC TDUMP  =  $D6 
;DEFC TON    =  $396 
;DEFC TOFF   =  $3A6 
;DEFC CURPOS =  $37E 
;DEFC SPACE  =  $144 
;DEFC NL     =  $35B 
;DEFC PMSG   =  $34E 

;* CONSTANTS
 DELETE   EQU   $7F

;* MEMORY ALLOCATION
 BUFF   EQU   $1000	; reserve also space for stack

; IOCON   EQU   BUFF+255
; USROUT  EQU   IOCON-2 
; CURSOR  EQU   USROUT-2 
; LSTCHR  EQU   CURSOR-2 
; STACK   EQU   LSTCHR-2 
;
; TB   EQU   BUFF+50 
; XBF   EQU   TB+50 

 STACK   EQU   BUFF-2
 ;;STACK   EQU   $FFFE

 TB     EQU   BUFF+50
 XBF    EQU   TB+50

 EDBUF  EQU   BUFF+256
 CURSP  EQU   EDBUF+250
 CSP    EQU   CURSP+1
 ARYLOC EQU   CSP+2
 SEED   EQU   ARYLOC+1
 VARS   EQU   SEED+2
 RFLAG  EQU   VARS+52
 IFLAG  EQU   RFLAG+1
 P      EQU   IFLAG+1
 EFLAG  EQU   P+1
 DATA   EQU   EFLAG+1
 LAST   EQU   DATA+2
 TEMP   EQU   LAST+2
 TEXT   EQU   VARS+1024

	;PAGE

;*
;****************************
;*  START OF MAIN PROGRAM   *
;* 'NEW' or 'RUN if patched *
;****************************
;*

	ORG	$100

	;; Unallocate unneded memory (needed by EXEC)
	;
	;mov	bx,4096		; 4096 * 16 = 64K
	;mov     ah,4ah          ; Resize memory block
	;int     21h		; ..keep only the current segment
				; so we can "shell to" other commands	

	; ### PATCH HERE WITH 2 NOPs (90h) TO PACKAGE ##
	; ### THE INTERPRETER WITH A TRAILING PROGRAM ##

	JMP	short NEW

chkstdin:	MOV	AX,258
		MOV	[UNGET],AX
		call	INCH
		AND	AH,1
		JNZ	chkstdin
		MOV	[UNGET],AX

;chkstdin:
;	mov	ah,$0b
;	int	21h
;	cmp	al,al
;	jz	chkstdin
	
	MOV	SP,STACK	;FIX UP STACK IN CASE WE ABORTED SOMETHING
	
	MOV	BX,TEXT
	SUB	BX,TAIL
	
	MOV	SI,65535
	MOV	DI,SI
	SUB	SI,BX
	STD
	MOV	CX,65536-TEXT
	
	REP	MOVSB
	
	JMP	RUN
	
		
;	MOV 	AL,$00C		;CHARACTER TO CLEAR SCREEN
;	CALL	OUTCH		;CLEAR VIDEO SCREEN
	
;*
;********************************************************************
;* START OF MAIN PROGRAM, FIRST INITIALIZE, INSURING WE DON'T THINK *
;* WE HAVE A VALID PROGRAM, ALSO CLEAR OUT HIS VARIABLES AND ARRAYS *
;********************************************************************
;*

NEW:	MOV	AX,3		;INIT VIDEO (CO80)
	INT	10h
	mov	ax,1112h	;SET TO 50 ROWS MODE
	int	10h

	MOV 	AL,$0FF		;INDICATES END OF PROGRAM
	MOV	[TEXT],AL	;INITIALIZE TO NO PROGRAM
RESV:	CALL	CLEAR		;CLEAR OUT HIS VARIABLES
;* RESET FLAGS, AND PROMPT WITH 'READY', SO HE WILL KNOW WE ARE LISTENING
INIT:	MOV	BX,0		;GET DOUBLE BYTE ZERO
	MOV	[RFLAG],BX	;INDICATE NOT RUNNING, AND NOT INPUT
	MOV	[P],BX		;INDICATE NO ASSIGNMENT DONE
	MOV	BX,RDY		;ADDRESS OF 'READY' MESSAGE
	CALL	PMSG		;TELL HIM WE ARE READY
;* GET A LINE FROM CONSOLE, AND SEE WHAT HE WANTS
TOP:	MOV	SP,STACK	;FIX UP STACK IN CASE WE ABORTED SOMETHING
	CALL	GLINE		;LET HIM GIVE US A LINE
	CMP	AL,$0D		;DID HE ONLY PRESS RETURN
	JZ 	TOP		;NOT GOOD ENOUGH, MAKE HIM TRY AGAIN
	CALL	NUM		;DID HIS LINE START WITH A NUMBER
	JNC 	NEAR EDIT		;IF SO, HE IS WRITEING A PROGRAM!!!
;* LOOK UP COMMAND AND EXECUTE
	MOV	CX,INIT		;ADDRESS TO RETURN TO
	PUSH	CX		;SAVE SO WE CAN RETURN
	MOV	BX,KTAB-1	;POINT TO COMMAND TABLE
;*
;* LOCATES COMMAND POINTED TO BY D-E IN THE COMMAND TABLE POINTED TO BY H-L
;* AND CHAINS TO THE COMMAND PROCESSING CODE FOR THAT COMMAND
;*
CMD:	CALL	PARSE1		;ADVANCE TO NEXT CHARACTER
TLP0:	PUSH	DX		;SAVE POINTER TO START OF COMMAND
CMDL:
 	INC	BX		;ADVANCE IN TABLE
	MOV	BP,DX		;GET COMMAND POINTER
	INC	DX		;ADVANCE IN COMMAND
	MOV	AL,[BP]		;GET DATA FROM COMMAND
	CMP	AL,[BX]		;COMPARE WITH TABLE CONTENTS
	JZ 	CMDL		;IF SAME, KEEP TESTING
;* DIDN'T MATCH, SEE IF IT'S END OF WORD (HIGH BIT SET)
	;OR	AL,$80		;ARE WE AT END?
	XOR	AL,$80		;ARE WE AT END?
	CMP	AL,[BX]		;AND IS IT THIS ONE?
	JZ 	GOTCMD	;IF SO, WE HAVE IT
;* WASN'T THAT ENTRY, KEEP LOOKING
	SUB	AL,AL		;SEE IT THIS IS END OF TABLE
	CMP	AL,[BX]		;ARE WE AT END?
	JZ 	GOTDEF	;IF SO, WE WILL SAY WE FOUND
	POP	DX		;RESTORE POINTER TO COMMAND
CMD1:	OR	AL,[BX]		;TEST FOR AT END OF TABLE ENTRY
	LAHF
	INC	BX		;POINT TO NEXT
	SAHF
	JNS 	CMD1		;IF NO, KEEP LOOKING
	INC	BX		;SKIP FIRST ADDRESS BYTE
	JMP	TLP0		;TEST THIS ENTRY
;* WE HIT THE END OF THE TABLE, ASSUME THE DEFAULT ADDRESS (LET)
GOTDEF:
 	DEC	DX		;BACKUP TO START OF WORD
;* WE MATCHED ALL THE WAY TO THE END OF A COMMAND WORD, GET IT'S ADDRESS
GOTCMD:
 	INC	BX		;POINT TO ADDRESS BYTE
	;MOV 	CL,[BX]		;SAVE TEMPORARY
	;INC	BX		;POINT TO NEXT ADDRESS BYTE
	;MOV 	BH,[BX]		;GET LOW ADDRESS
	;MOV 	BL,CL		;GET HIGH ADDRESS
	MOV	BX,[BX]
	POP	BP  ; Was: EX	(SP),HL		;PLACE CODE ADDRESS ON STACK, REMOVE TRASH
	PUSH	BX
	MOV	BX,BP
	JMP	PARSE1		;SKIP TO NEXT NON-BLANK, AND CHAIN TO CODE
;*
;****************************************************************
;*              ERROR CHECKING AND HANDLING CODE
;****************************************************************
;*
;* VCHAR... TESTS FOR A VALID VARIABLE, SYNTAX ERROR IF NOT
;*
VCHAR:	CALL	FNCHAR		;TEST VARIABLE
 
	JNC	L86L2		;IF OK, GO BACK (RET)

;*
;* SYNTAX ERROR... HE'S NOT MAKEING ANY SENSE AT ALL
;* ISSUE NASTY MESSAGE TO STRAIGHTEN HIM OUT
;*
SYNT:	MOV	BX,SYN		;GET NASTY 'SYNTAX' MESSAGE
	DEC	DX		;BACK UP IN SOURCE SO WE DONT SAY WRONG LINE
;*
;* ERROR STUFF... SOMETHING HAS GONE WRONG... TELL HIM THE BAD NEWS AND
;* QUIT ANYTHING THAT WE MAY HAVE STARTED, SO THAT THINGS CAN'T GET WORSE
;* ALSO, IF WE WERE RUNNING, GIVE HIM THE LINE NUMBER AS A CLUE
;*
ERR:	MOV 	AL,'?'		;PRECEDE ERROR MESSAGE BY '?'
	CALL	OUTCH		;DISPLAY ON TERMINAL
	MOV	AL,[IFLAG]	;WERE WE TRYING TO 'INPUT' SOMETHING
	AND	AL,AL		;IF WE WERE, THEN ..
	JNZ 	NEAR INERR	;SPECIAL MESSAGE + HANDLEING
;* NOW THAT WE HAVE FIGURED OUT WHAT'S GOING ON, LET HIM IN ON IT
	CALL	PMSG		;PRINT ERROR MESSAGE
	MOV	BX,EM		;FOLLOWED BY..
;* PRINT MESSAGE FOLLOWED BY LINE NUMBER (ALSO USED BY 'STOP IN LINE XXXX')
PERR:	CALL	PMSG		;THE ' ERROR ' PART
	MOV	AL,[RFLAG]	;WERE WE RUNNING..
	AND	AL,AL		;IF NOT,
	JZ 	INLF		;THEN THATS ALL WE HAVE TO DO
;* DISPLAY LINE NUMBER OF RUNNING PROGRAM
	MOV	BX,INL		;ADDRESS OF 'IN LINE ' MESSAGE
	CALL	PMSG		;DISPLAY FOR HIM
;* FIND START OF OUR LINE, AND DISPLAY LINE NUMBER
FSOL:
 	DEC	DX		;BACK UP IN SOURCE
	MOV 	AL,DH		;GET HIGH BYTE OF ADDRESS
	CMP	AL,TEXT/256	;TEST FOR BEYOND BEGINNING
	JC 	STLIN		;AT START OF LINE
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER FROM BUFER
	CMP	AL,$0D		;TEST FOR CARRIAGE RETURN
	JNZ 	FSOL		;IF NOT, KEEP LOOKING
STLIN:
 	INC	DX		;ADVANCE IN SOURCE
	XCHG	DX,BX		;SWAP TO H-L FOR PNUM
	CALL	PNUM		;PRINT AND BUFFER LINE NUMBER
;* COPY LINE WITH ERROR INTO OLD LINE EDIT BUFFER, INCASE HE WANTS TO FIX IT
FIXIT:
 	INC	BX		;SKIP LENGTH BYTE, ADVANCE TO NEXT IN SOURCE
	MOV 	AL,[BX]		;GET CHARACTER FROM LINE
	MOV	BP,DX
	MOV	[BP],AL		;SAVE IN BUFFER
	INC	DX		;ADVANCE TO NEXT IN BUFFER
	CMP	AL,$0D		;TEST FOR END-OF-LINE
	JNZ 	FIXIT		;IF NOT, KEEP COPYING
;* WAIT FOR CONSOLE INPUT, ON A NEW LINE
INLF:	CALL	NL		;ADVANCE A LINE ON HIS TERMINAL
	CALL	RESET		;RESET DATA POINTER AND CONTROL-STACK
	JMP	INIT		;GET NEXT COMMAND
;*
;* SUBROUTINE TEST FOR VALID ASCII DIGIT (0-9), RETURNS WITH C=1 IF NOT
;*
NUM:	CMP	AL,'0'		;TEST FOR < '0'
	JC	L86L2		;IF SO, BAD DIGIT
	CMP	AL,$03A		;TEST FOR >'9'
	CMC			;INVERT LOGIC, C=1 IF BAD
L86L2:
	RET

INKEY:	CALL	VCHAR		;TEST FOR VALID VARIABLE NAME
	PUSH	AX		;KEEP VARIABLE NAME
	CALL	INCH
	MOV	BX,AX
	;MOV	BL,AL
	POP	AX
	CALL	STOR		; PUT ASCII CODE IN INTEGER VALUE
	RET

;*
;****************************************************************
;*                    TEXT EDITING ROUTINES
;****************************************************************
;*
;* SUBROUTINE TO GET AND EDIT COMMAND LINE FROM TERMINAL
;*
BADLN:	CALL	NL		;ADVANCE TO NEW LINE
GLINE:	MOV	DX,BUFF		;POINT TO INPUT BUFFER
	MOV	BX,EDBUF	;POINT TO EDIT BUFFER
	MOV 	CH,DL		;CLEAR INSERT FLAG [LOW ADR OF BUFFER IS ZERO]
LOOP1:	MOV 	AL,DL		;GET LOW ADDRESS OF OUR POSITION
	AND	AL,AL		;TEST FOR NEGATIVE
	JS 	BADLN		;IF SO, HE'S DELETED BEYOND START OF BUFFER
	CALL	INCH		;GET A CHARACTER
	CMP	AL,3		;TEST FOR CONTROL-C [CANCEL]
	JZ 	INLF		;IF SO, ABORT BACK TO COMMAND HANDLER
	CMP	AL,6		;TEST FOR CONTROL-F [FIND COMMAND]
	JZ 	NEAR GFIND		;EXECUTE FIND
	CMP	AL,1		;TEST FOR CONTROL-A [ADVANCE COMMAND]
	JZ 	GADV		;EXECUTE ADVANCE
	CMP	AL,9		;TEST FOR CONTROL-I [TOGGLE INSERT MODE]
	JZ 	NEAR GINST		;TOGGLE INSERT MODE
	CMP	AL,4		;TEST FOR CONTROL-D [DELETE CHARACTER.]
	JZ 	GRUB		;ERASE CHARACTER
	CMP	AL,' '		;TEST FOR CONTROL-CHARACTER
	JNC 	OKPRT	;IF NOT, OK TO PROCESS
	CMP	AL,$0D		;CARRIAGE RETURN IS OK,
	JZ 	OKPRT		;SO PROCESS IT
	CMP	AL,8		;SO IS A BACKSPACE
	JNZ 	LOOP1	;ANYTHING ELSE SHOULD BE IGNORED
;* WE HAVE GOTTEN A VALID CHARACTER
OKPRT:	CMP	AL,DELETE		;TEST FOR DELETE CHARACTER
	JNZ 	RECT		;IF IT IS A DELETE,
	MOV 	AL,8		;MAKE IT INTO A BACKSPACE
RECT:	MOV 	CL,AL		;COPY INTO C
	CALL	OUTCH		;DISPLAY ON TERMINAL !!!!
	DEC	DX		;ASSUME DELETE (BACKSPACE)
;* DON'T DELETE CHARS FROM OLD LINE BUFFER IF WE ARE INSERTING
	OR	AL,CH		;TEST INSERT FLAG
	JS 	IND		;IF NOT, WE ARE INSERTING
	DEC	BX		;REDUCE OLD BUFFER POSITION
IND:	MOV 	AL,CL		;GET CHARACTER BACK
	CMP	AL,8		;TEST FOR DELETE [BACKSPACE]
	JZ 	LOOP1		;IF SO, WE WERE RIGHT, GET NEXT CHARACTER
	INC	DX		;FIX OUR MISTAKE (NOT DELETE)
	MOV	BP,DX
	MOV	[BP],AL		;SAVE CHARACTER IN BUFFER
;* DON'T MOVE OLD LINE POINTER IF WE ARE INSERTING
	OR	AL,CH		;TEST INSERT FLAG
	JS 	INOK		;IF SO, DON'T INCREMENT
	INC	BX		;ADVANCE IN OLD LINE BUFFER
	MOV 	AL,[BX]		;GET CHARACTER FROM OLD LINE
	CMP	AL,$0D		;TEST FOR END OF OLD LINE
	JZ 	INOK		;IF SO, DON'T GO PAST IT
	INC	BX		;ADVANCE TO NEXT CHARACTER OF OLD LINE
INOK:	MOV 	AL,CL		;GET CHARACTER BACK
	INC	DX		;ADVANCE POINTER IN NEW LINE
	CMP	AL,$0D		;TEST FOR CARRAIGE RETURN [END OF LINE]
	JNZ 	LOOP1	;IF NOT, KEEP GETTING CHARACTERS
	CALL	NL		;PRINT LINE-FEED CARRIAGE RETURN
;* COPY NEW LINE INTO OLD LINE BUFFER (MAKEING IT THE 'NEW' OLD LINE)
	MOV	DX,BUFF		;POINT BACK TO NEW LINE BUFFER
	PUSH	DX		;SAVE BUFFER ADDRESS
	MOV	BX,EDBUF	;POINT TO OLD LINE BUFFER
MOVL:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM NEW LINE
	MOV 	[BX],AL		;SAVE IN OLD LINE BUFFER
	INC	BX		;POINT TO NEXT
	INC	DX		;POINT TO NEXT
	CMP	AL,$0D		;TEST FOR END OF LINE
	JNZ 	MOVL		;IF NOT, KEEP MOVEING
	POP	DX		;RESTORE BUFFER ADDRESS
	MOV	BP,DX
	MOV	AL,[BP]		;AND FIRST CHARACTER FROM IT
	RET
;* COPY ONE CHARACTER FROM OLD LINE TO NEW LINE
GADV:	MOV 	AL,[BX]		;GET CHARACTER FROM OLD LINE
	CMP	AL,$0D		;INSURE ITS NOT THE END
	JZ 	LOOP1		;IF SO, IGNORE COMMAND
	OR	AL,CH		;TEST INSERT FLAG
	MOV 	AL,[BX]		;GET CHARACTER BACK
	JNS 	RECT		;IF NO INSERT, OK
	INC	BX		;ADVANCE TO NEXT
	JMP	RECT		;PASS CHARACTER TO INPUT ROUTINE
;* RUB OUT ONE CHARACTER FROM THE OLD LINE
GRUB:	MOV 	AL,[BX]		;GET CHARACTER FROM OLD LINE
	CMP	AL,$0D		;TEST FOR END OF LINE
	JZ 	LOOP1		;IF SO, IGNORE COMMAND
	MOV 	AL,'*'		;INDICATE RUBBED OUT CHARACTER WITH '*'
	CALL	OUTCH		;PRINT  IT TO SHOW WHAT WE ARE DOING
	INC	BX		;ADVANCE PASSED CHARACTER (RUBBING IT OUT)
	JMP	LOOP1		;RETURN FOR NEXT CHARACTER
;* FIND NEXT CHARACTER IN NEW LINE
GFIND:	CALL	INCH		;GET A CHARACTER
	MOV 	CL,AL		;SAVE IN C [TO COMPARE AGAINST.]
	PUSH	BX		;SAVE POSITION IN OLD LINE
;* FIND OUT IF IT IS THERE..
GF1:	MOV 	AL,[BX]		;GET CHARACTER FROM OLD LINE
GF0:	CMP	AL,$0D		;TEST FOR END OF LINE
	JZ 	ABFND		;IF SO, WE DIDN'T FIND IT
	INC	BX		;ADVANCE TO NEXT CHARACTER
	MOV 	AL,[BX]		;GET CHARACTER
	CMP	AL,CL		;TEST FOR CHARACTER WE DESIRE
	JNZ 	GF0		;IF NOT, KEEP LOOKING
	POP	BX		;RESTORE POSITION ON OLD LINE
;* NOW COPY OLD LINE OVER..
GF2:	MOV 	AL,[BX]		;GET CHARACTER FROM OLD LINE
GF3:
	MOV	BP,DX
 	MOV	[BP],AL		;SAVE IN NEW LINE
	CALL	OUTCH		;DISPLAY ON TERMINAL
	INC	BX		;POINT TO NEXT CHAR. IN OLD LINE
	INC	DX		;POINT TO NEXT CHAR IN NEW LINE
	MOV 	AL,[BX]		;GET NEXT CHAR FROM NEW LINE
	CMP	AL,CL		;TEST FOR CHARACTER WE WANT
	JNZ 	GF3		;IF NOT, KEEP COPYING
	PUSH	BX		;FIX UP STACK
ABFND:	POP	BX		;RESTORE POSITION IN OLD LINE
	JMP	LOOP1		;GET NEXT CHARACTER
;* TOGGLE INSERT MODE
GINST:	MOV 	AL,CH		;GET INSERT MODE FLAG
	XOR	AL,$0FF		;COMPLEMENT, SETTING FLAGS
	MOV 	CH,AL		;REAVE IN FLAG REGISTER
	MOV 	AL,'<'		;INDICATE ENTERING INSERT MODE
	JS 	GIN1		;IF SO, INDICATE SO
	MOV 	AL,'>'		;INDICATE LEAVING INSERT
GIN1:	CALL	OUTCH		;DISPLAY INDICATOR ON TERMINAL
	JMP	LOOP1		;GET NEXT CHARACTER FROM TERMINAL
;*
;* GET A PACKED-DECIMAL LINE NUMBER FROM THE COMMAND BUFFER
;*
GETLN:	MOV	BX,0		;START WITH ZERO
ELOOP:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET DIGIT FROM COMMAND BUFFER
	CALL	NUM		;TEST FOR ASCII DIGIT
	JC	short L86L3	;IF NOT, STOP (WE HAVE IT)
	INC	DX		;ADVANCE TO NEXT BUFFER POSITION
	ROL	BX,4
	;ADD	BX,BX		;MAKE ROOM FOR DIGIT IN BOTTOM..
	;ADD	BX,BX		;OF THE RESULT, BY ..
	;ADD	BX,BX		;ROTATING IT..
	;ADD	BX,BX		;LEFT BY FOUR BITS
	AND	AL,$00F		;CONVERT DIGIT TO BINARY
	OR	AL,BL		;INSERT INTO LOWER DIGITS OF RESULT
	MOV 	BL,AL		;AND REPLACE BYTE IN RESULT WITH NEW VALUE
	JMP	ELOOP		;GET NEXT DIGIT
L86L3:	RET
;*
;* LINE EDITOR, EDITS PROGRAM SOURCE BY LINE NUMBER IN COMMAND BUFFER
;*
EDIT:	CALL	LINEF		;LOCATE LINE NUMBER IN SOURCE
	PUSH	BX		;SAVE POINTER INTO TEXT
	JNZ 	INS		;IF NEW LINE, DON'T TRY TO DELETE
;* DELETE LINE POINTED TO BY H-L
DEL:	;MOV 	DH,BH		;COPY POINTER INTO
	;MOV 	DL,BL		;THE D-E PAIR FOR BACKWARDS COPY
	MOV	DX,BX
	MOV 	AL,$0D		;WE ARE LOOKING FOR A CARRIAGE RETURN
;* FIND START OF NEXT LINE
DELNX:	CMP	AL,[BX]		;TEST FOR END OF LINE TO DELETE
	LAHF
	INC	BX		;POINT TO NEXT CHARACTER IN SOURCE
	SAHF
	JNZ 	DELNX		;IF NOT END OF LINE, KEEP LOOKING
;* COPY REST OF PROGRAM BACK OVER DELETED LINE
DELLP:	MOV 	AL,[BX]		;GET CHARACTER FROM NEXT LINE
	MOV	BP,DX
	MOV	[BP],AL		;SAVE OVER DELETED LINE
	INC	DX		;POINT TO NEXT IN NEW LINE
	INC	BX		;POINT TO NEXT IN OLD LINE
	INC	AL		;TEST FOR END OF FILE
	JNZ 	DELLP	;IF NOT, KEEP DELETEING
;* INSERT LINE INTO TEXT
INS:	MOV	CX,2		;SET LENGTH TO 2 [PACKED DECIMAL NUMBERS ARE 2]
	MOV	DX,BUFF		;POINT TO BUFFER [CONTAINING NEW LINE]
;* CALCULATE LENGTH OF LINE
	CALL	GETLN		;REMOVE NUMBERS AS THEY ARE NOT STORED AS TEXT
ILP:	INC	CL		;INCREMENT LENGTH
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER FROM NEW LINE {IN BUFFER}
	INC	DX		;POINT TO NEXT CHARACTER FROM NEW LINE
	CMP	AL,$0D		;TEST FOR END OF LINE
	JNZ 	ILP		;IF NOT, KEEP COUNTING
	MOV 	AL,CL		;GET LENGTH
	POP	BX		;RESTORE POSITION IN TEXT
	CMP	AL,3		;TEST FOR NULL LINE
	JZ 	TOP		;IS SO, DON'T INSERT
;* INSERT NEW LINE INTO TEXT
INLN:	;MOV 	DH,BH		;SET D-E TO POINT TO
	;MOV 	DL,BL		;THE LINE POSITION
	MOV	DX,BX
	CALL	GETEOF		;GET END OF FILE ADDRESS
	INC	BX		;ADVANCE TO FREE BYTE
	PUSH	CX		;SAVE LENGTH
	PUSH	BX		;STACK END OF FILE ADDRESS
	ADD	BX,CX		;ADD LENGTH
	POP	CX		;GET END OF FILE ADDRESS
	INC	BX		;ADVANCE BECAUSE WE DECREMENT
IL01:
 	DEC	BX		;REDUCE POINTER INTO NEW POSITION
	DEC	CX		;REDUCE POINTER TO OLD POSITION
	MOV	BP,CX
	MOV	AL,[BP]		;GET BYTE OF OLD DATA
	MOV 	[BX],AL		;SAVE IN NEW POSITION
	MOV 	AL,CL		;GET LOW ADDRESS
	CMP	AL,DL		;TEST AGAINST WHERE WE ARE GOING
	JNZ 	IL01		;IF NOT, KEEP COPYING
	MOV 	AL,CH		;GET HIGH ADDRESS
	CMP	AL,DH		;TEST AGAINST DESTINATION
	JNZ 	IL01		;IF NOT SAME, KEEP COPYING
	MOV	DX,BUFF		;GET ADDRESS OF NEW LINE
	CALL	GETLN		;OBTAIN NUMBERS
	;;MOV 	AL,BH		;GET HIGH 2 DIGITS
	MOV	BP,CX
	MOV	[BP],BH
	INC	BP
	MOV	[BP],BL
	;;MOV	[BP],AL		;SAVE IN NEW LINE
	;;INC	CX		;POINT TO NEXT CHARACTER OF NEW LINE
	;;MOV 	AL,BL		;GET LOW DIGITS
	;;MOV	BP,CX
	;;MOV	[BP],AL		;SAVE IN NEW LINE
	INC	CX
	INC	CX		;ADVANCE TO NEXT CHARACTER IN NEW LINE
	POP	BX		;RESTORE LENGTH
	MOV 	AL,BL		;GET LENGTH
	ADD	AL,$010		;ADD OFFSET TO MAKE UNIQUE
	MOV	BP,CX
	MOV	[BP],AL		;SAVE IN NEW LINE
	INC	CX		;POINT TO NEXT CHARACTER
IL02:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM NEW LINE IN BUFFER
	MOV	BP,CX
	MOV	[BP],AL		;SAVE IN TEXT
	INC	CX		;POINT TO NEXT POSITION IN TEXT
	INC	DX		;ADVANCE IN BUFFER
	CMP	AL,$0D		;TEST FOR END OF LINE
	JNZ 	IL02		;IF NOT, KEEP LOOKING
;* WE ARE INSERTING OR REPLACEING A LINE, SINCE WE DON'T KNOW HOW MUCH
;* MEMORY IT WILL REQUIRE, WE MUST CLEAR THE ARRAYS, AS THEY FOLLOW THE
;* PROGRAM. WE DO NOT HAVE TO DO THIS WHEN DELETING LINES
	CALL	CLRARY		;CLEAR ARRAYS AND RETURN
	JMP	TOP		;GO BACK FOR NEXT COMMAND
;*
;* LOCATE LINE IN TEXT, SYNTAX ERROR IF NOT LINE NUMBER
;*
FNDLIN:	CALL	NUM		;IS IT A VALID NUMBER
	JC 	SYNT		;IF NOT, IT'S A INVALID
;*
;* FINDS LINE IN PROGRAM TEXT. RETURNS WITH Z FLAG SET IF LINE EXISTS
;* H-L POINTS TO START OF LINE. B-C CONTAINS LINE NUMBER OF ACTUAL
;* LINE FOUND. (IF LINE NOT FOUND, POINTS TO FIRST GREATER LINE NUMBER)
;*
LINEF:	CALL	GETLN		;GET LINE NUMBER FROM COMMAND BUFFER
	XCHG	DX,BX		;SWAP TO D-E
	MOV	BX,TEXT		;START AT TOP OF PROGRAM
TRY:	MOV 	AL,[BX]		;GET FIRST CHARACTER FROM PROGRAM LINE
	CMP	AL,$0FF		;TEST FOR END OF FILE
	JZ 	EOF		;IF SO, WE DIDN'T FIND
	INC	BX		;ADVANCE POINTER TO LOW DIGITS
	CMP	AL,DH		;TEST FOR HIGH DIGITS CORRECT
	JC 	NEXTL		;IF LESS, FIND NEXT LINE
	JNZ 	NOTFND	;IF GREATER, LINE WASN'T FOUND
	MOV 	AL,[BX]		;GET LOW DIGITS
	CMP	AL,DL		;TEST LOW DIGITS
	JNC 	NOTFND	;IF LESS, LINE IS HERE OR DOSN'T EXIST
;* ADVANCE TO NEXT LINE IN SOURCE
NEXTL:
 	INC	BX		;POINT TO LINE LENGTH
	MOV 	AL,[BX]		;GET LENGTH
	SUB	AL,$011		;SUBTRACT OFFSET USED TO MAKE IT UNIQUE
	ADD	AL,BL		;ADD TO POINTER
	MOV 	BL,AL		;AND REPLACE IN POINTER
	JNC 	TRY		;IF NO CARRY, THATS IT
	INC	BH		;BUMP HIGH ADDRESS
	JMP	TRY		;AND TEST THIS LINE
;* LINE IS HERE OR BEFORE
NOTFND:
 	DEC	BX		;BACK UP TO DIGIT
	MOV 	CL,AL		;PLACE LOW ORDER DIGIT IN C
	MOV 	CH,[BX]		;PLACE HIGH ORDER DIGIT IN B
	CMP	AL,DL		;TEST FOR LINE FOUND
	JNZ	L86L4		;IF NOT SAME, RETURN INDICATING SO
	MOV 	AL,CH		;GET HIGH DIGIT
	CMP	AL,DH		;INDICATE IF NUMBERS SAME
	RET
;* LINE WAS GREATER THAN ALL LINES IN PROGRAM, INDICATE EOF REACHED
EOF:	MOV 	CH,AL		;RETURN HIGH LINE NUMBER
	AND	AL,AL		;INDICATE LINE DOSN'T EXIST
L86L4:
	RET
;*
;* PRINTS PACKED-DECIMAL LINE NUMBER ON TERMINAL, AS WELL AS PLACEING
;* IT AT THE START OF THE EDIT BUFFER
;*
PNUM:	MOV	DX,EDBUF	;SET UP POINTER TO EDIT BUFFER
	CALL	HPOUT		;PRINT FIRST TWO DIGITS
HPOUT:	MOV 	AL,[BX]		;GET CONTENTS OF MEMORY
	INC	BX		;AND POINT TO NEXT
	PUSH	AX		;SAVE FOR LATER
	ROR	AL,4
	;ROR	AL,1			;ROTATE
	;ROR	AL,1			;UPPER DIGIT
	;ROR	AL,1			;INTO
	;ROR	AL,1			;LOWER DIGIT
	CALL	POUT		;DISPLAY UPPER DIGIT
	POP	AX		;GET LOWER DIGIT BACK
;* DISPLAYS ONE DIGIT
POUT:	AND	AL,$00F		;REMOVE UPPER GARBAGE
	OR	AL,$030		;CONVERT TO ASCII DIGIT
	MOV	BP,DX
	MOV	[BP],AL		;SAVE IN EDIT BUFFER
	INC	DX		;ADVANCE POINTER IN EDIT BUFFER
	JMP	OUTCH		;DISPLAY DIGIT ON TERMINAL AND RETURN
;*
;******************************************************************
;*                   BASIC COMMAND HANDLERS
;******************************************************************
;*
;* IT'S A 'LIST' COMMAND, LETS GIVE HIM A PEEK AT THE SOURCE
;* ALSO PLACE LAST LINE LISTED IN BUFFER, INCASE HE WANTS TO EDIT IT
;*
LIST:	PUSH	DX		;SAVE PROGRAM POINTER
	MOV	BX,TEXT		;START AT THE BEGINNING OF THE PROGRAM
	MOV 	CH,255		;SET ENDING LINE BEYOND END OF TEXT
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER OF OPERAND
	CALL	NUM		;TEST FOR A NUMBER
	JC 	GO		;IF NOT, LIST WHOLE THING
	CALL	GETLN		;GET LINE NUMBER
	PUSH	BX		;SAVE ON STACK
	INC	DX		;POINT TO NEXT CHARACTER
	CMP	AL,','		;TEST FOR ENDING NUMBER
	JZ	L86L5
	CALL	LINEF		;IF SO, GET ENDING NUMBER
L86L5:
	INC	BX		;ADVANCE PAST BEGINNING OF LINE
	POP	DX		;GET STARTING LINE NUMBER BACK
	PUSH	BX		;SAVE ENDING LINE
	CALL	LINEF+4		;FIND STARTING LINE ADDRESS
	POP	CX		;GET ENDING ADDRESS BACK
;* LIST TEXT FROM STARTING LINE IN H-L TO ENDING LINE IN B-C
GO:	MOV 	AL,[BX]		;GET CHARACTER FROM START OF LINE
	INC	AL		;TEST FOR END OF FILE
	JZ 	LIRET		;IF SO, STOP LISTING
	CALL	PNUM		;DISPLAY LINE NUMBER AND BUFFER IT
	INC	BX		;SKIP LENGTH BYTE, AS IT DOSN'T LOOK PRETTY
PRINS:	MOV 	AL,[BX]		;GET CHARACTER FROM LINE
	MOV	BP,DX
	MOV	[BP],AL		;PLACE INTO BUFFER
	INC	DX		;ADVANCE IN BUFFER
	CALL	OUTCH		;DISPLAY ON TERMINAL
	INC	BX		;ADVANCE POINTER IN PROGRAM
	CMP	AL,$0D		;TEST FOR END OF LINE
	JNZ 	PRINS		;IF NOT, KEEP PRINTING
	CALL	NL		;NEW LINE ON TERMINAL
	CMP	BX,CX		;TEST FOR LAST LINE LISTED
	JNC 	LIRET		;IF SO, STOP LISTING
	;;CALL	CTRLC		;TEST FOR ABORT FROM TERMINAL
	;;JNZ 	GO		;KEEP LISTING IF NOT
	JMP	GO
LIRET:	POP	DX		;RESTORE PROGRAM POINTER
	RET
;*
;* CLEARS VARIABLES AND ARRAYS. (INITIALIZES THEM) AND INITIALIZES EDIT BUFFER
;*
CLEAR:	MOV	BX,VARS		;POINT TO VARIABLE SPACE
	MOV 	AL,$0D		;GET A CARRIAGE RETURN [END OF LINE CHARACTER]
	MOV	[EDBUF],AL	;INITIALIZE EDIT BUFFER TO A NULL LINE
	MOV 	CL,52		;26 VARIABLE TIMES 2 BYTES/VARIABLE
CVLP:	MOV 	byte [BX],0		;CLEAR INTEGER VARAIBLES TO ZERO
	INC	BX		;ADVANCE TO NEXT BYTE OF VARIABLE SPACE
	DEC	CL		;REDUCE COUNT OF VARAIABLES LEFT
	JNZ 	CVLP		;KEEP GOING TILL ALL INTEGERS ARE ZERO'ED
	MOV 	AL,TEXT/256	;ADDRESS OF END OF VARIABLE TABLE
	MOV	CX,10		;SKIP AHEAD 10 BYTES
	ADD	BX,CX		;SO THAT WE DON'T CLOBBER OUR FLAGS
CVL1:	MOV 	byte [BX],255	;$FF IS NULL CHARACTER FOR CHAR. VARS
	INC	BX		;POINT TO NEXT BYTE IN CHAR. VAR. SPACE
	CMP	AL,BH		;TEST FOR COMPLETE [ALL SET TO NULL STRINGS]
	JNZ 	CVL1		;KEEP GOING TILL WE DO THEM ALL
;* INITIALIZE ARRAYS, RESET ARRAY SPACE TO FIRST PAGE FOLLOWING PROGRAM
CLRARY:	CALL	GETEOF		;GET ADDRESS OF FIRST FREE PAGE+SET POINTER
	MOV	[ARYLOC],AL	;STASH IN ARRAY TABLE POINTER
	MOV 	BH,AL		;PLACE IN H, SO WE CAN REFERENCE INDERECT
	MOV 	BL,52		;START AT END OF TABLE
	MOV	[LAST],BX	;INDICATE FREE SPACE FOR NEXT ARRAY
	SUB	AL,AL		;GET A ZERO
CALS:	DEC	BL		;BACK UP IN TABLE
	MOV 	[BX],AL		;INITIALIZE TO INDICATE NO ARRAY
	JNZ 	CALS		;KEEP GOING TILL TABLE IS CLEARED
;* RESET CONTROL STACK AND DATA POINTER
RESET:	MOV	BX,CS		;GET USER STACK POINTER
	MOV	[CSP],BX	;INITIALZE USER STACK POINTER
	MOV	BX,0		;GET A ZERO [NO DATA POINTER]
	MOV	[DATA],BX	;INSURE NO DATA PRESENT
	RET
;*
;* ** WE'VE GOTTEN A 'RUN' COMMAND, LETS START THE PROGRAM ROLLING **
;*
RUN:	MOV	AL,[TEXT]	;GET FIRST CHARACTER OF PROGRAM
	MOV	BX,NP		;AND ADDRESS OF 'NO PROGRAM' MESSAGE
	INC	AL		;TEST FOR EXISTANCE OF PROGRAM
	JZ 	ERR		;IF NOT, POINT OUT HIS MISTAKE
	CALL	CLEAR		;CLEAR VARIABLES AND ARRAYS
	MOV	DX,TEXT		;START INTERPRETING AT THE BEGINNING
RGON:	MOV 	AL,255		;INDICATE THAT WE ARE RUNNING
	MOV	[RFLAG],AL	;BY SETTING THIS FLAG
RNEWL:
 	INC	DX		;SKIP PACKED DECIMAL LINE
	INC	DX		;NUMBERS, AND THE LENGTH BYTE,
	INC	DX		;AS THE COMMAND FINDER WON'T LIKE IT
;* MAIN 'RUN' INTERPRETING LOOP
RLOOP:	MOV	SP,STACK	;REPAIR ANY DAMAGE
	;;CALL	CTRLC		;TEST FOR 'MAGIC' CONTROL-C CHARACTER
	;;JZ 	STOP		;IF SO, FAKE A 'STOP' COMMAND
	MOV	BX,PTAB-1	;POINT TO PROGRAM COMMAND TABLE
	CALL	CMD		;RUN PROGRAM CODE
;* ADVANCE TO NEXT STATEMENT
RNEXT:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,$22		;TEST FOR A QUOTE
	JNZ	L86L6
	CALL	SKPQUO		;IF SO, SEARCH FOR NEXT ONE
L86L6:
	INC	DX		;ADVANCE TO NEXT CHARACTER
	CMP	AL,':'		;TEST FOR COLON [NEW STATEMENT]
	JZ 	RLOOP		;IF SO, EXECUTE NEXT COMMAND
	CMP	AL,$0D		;TEST FOR CARRIAGE RETURN
	JNZ 	RNEXT	;IF NOT, KEEP LOOKING
	MOV	BP,DX
	MOV	AL,[BP]		;GET FIRST CHAR OF NEW LINE
	INC	AL		;TEST FOR $FF (END OF FILE)
	JZ 	INIT		;IF SO, GO BACK TO COMMAND MODE
	JMP	RNEWL		;EXECUTE THIS LINE
;*
;* EITHER WE HAVE GOTTEN A 'STOP' COMMAND, OR THE OPERATOR PRESSED
;* CONTROL-C, EITHER WAY, PRINT THE MESSAGE AND EXIT
;*
STOP:	MOV	BX,STMSG	;ADDRESS OF 'STOP' MESSAGE
	JMP	PERR		;TREAT IT LIKE AN ERROR
;* IT'S A 'THEN', FOLLOWING AN 'IF', LOOK FOR LINE NUMBER OR A STATEMENT
THEN:	CALL	NUM		;IS IT A NUMBER?
	JNC 	GOTO		;IF SO, ITS A NUMBER TO 'GOTO'
	JMP	RLOOP		;IF NOT, ITS A STATEMENT TO EXECUTE
;*
;* IT'S A 'GOSUB' SAVE RETURN ADDRESS, AND PRETEND IT'S 'GOTO'
;*
GOSUB:	CALL	PUSHD		;SAVE SOURCE POSITION
	SUB	AL,AL		;INDICATE GOSUB ENTRY
	CALL	PUSHS		;SAVE ON USER STACK
	MOV	BP,DX
	MOV	AL,[BP]		;RESTORE OPERAND CHARACTER
;*
;* IT'S A 'GOTO' MAKE THE BIG JUMP
;*
GOTO:	CMP	AL,'('		;TEST FOR COMPUTED GOTO
	JNZ 	NOON		;IF NO, NOT AN 'ON' STATEMENT
	CALL	EXPR		;GET VALUE OF INTERNAL EXPRESSION
GLPO:	CALL	SKIP		;SKIP TO NEXT EXPRESSION
	CMP	AL,','		;IF THERE IS NO MORE COMMA'S
	JNZ 	SYNT		;THEN WE RAN OUT OF OPERANDS
GLPD:
 	INC	DX		;SKIP THE COMMA
	DEC	BL		;REDUCE OUR COUNT
	JNS 	GLPO		;IF IT'S STILL POSITIVE, KEEP SKIPPING
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,' '		;TEST FOR BLANKS
	JZ 	GLPD		;AND KEEP GOING TILL WE SKIP THEM
NOON:	PUSH	DX		;SAVE POSITION (IN CASE WE FAIL)
	CALL	FNDLIN		;FIND THE LINE HE WANTS
	POP	DX		;RESTORE OUR POSITION
	XCHG	DX,BX		;SWAP NEW POS INTO D-E
	JZ 	RGON		;IF SUCESS, GOTO NEW LINE
	XCHG	DX,BX		;SWAP BACK
;*
;* OH OH, LOOKS LIKE HE'S TRIED TO GOTO, GOSUB OR ORDER TO A LINE HE FORGOT
;* TO TYPE IN, TELL HIM ABOUT IT AND LET HIM TRY TO FIGURE IT OUT
;*
BADLIN:	MOV	BX,LIN		;ADDRESS OF 'LINE NUMBER' MESSAGE
	JMP	ERR		;HANDLE LIKE ANY ERROR
;*
;* IT'S A 'RETURN', HOPE SOMEBODY DID A 'GOSUB' SOMEWHERE
;*
RETURN:	CALL	POPS		;GET TYPE OF STACK ENTRY
	AND	AL,AL		;TEST FOR 'GOSUB' ENTRY
	JZ 	POPD		;IF SO, GET ADDRESS BACK AND RETURN
;*
;* HE SCREWED UP THE FOR/NEXT, GOSUB/RETURN NESTING
;* LET HIM IN ON IT AND DIE WHILE WE CAN
;*
NSTERR:	MOV	BX,CSTK		;ADDRESS OF 'NESTING' MESSAGE
	JMP	ERR		;HANDLE LIKE ANY ERROR
;*
;* IT'S A 'FOR' COMMAND, LETS THROW THIS THING FOR A LOOP
;*
FOR:	CALL	VCHAR		;INSURE IT'S A VARIABLE
	PUSH	AX		;SAVE IT (IT'S THE LOOP INDEX VARIABLE)
	DEC	DX		;BACK UP POINT JUST BEFORE EXPRESSION
	MOV 	AL,DL		;GET LOW ADDRESS
	MOV	[P],AL		;AND PLACE IN POSITION FLAG
FINTO:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,$0D		;TEST FOR END OF LINE
	JZ 	SYNT		;IF SO, HE'S GOOFED
	INC	DX		;SKIP TO NEXT
	CMP	AL,'T'		;TEST FOR A 'T'
	JNZ 	FINTO	;IF NOT, WE ARN'T THERE YET
	MOV	BP,DX
	MOV	AL,[BP]		;GET NEXT CHARACTER
	CMP	AL,'O'		;IS IT 'TO'
	JNZ 	FINTO	;NO, MUST BE VARIABLE 'T'
	PUSH	DX		;SAVE OUR POSITION
	DEC	DX		;BACKUP TO THE 'T'
	CALL	DOEXP		;EVALUATE EXPRESSION
	POP	DX		;RESTORE OUT POSITION
	INC	DX		;SKIP 'O'
	CALL	EXPR		;GET LIMIT EXPRESSION
	CALL	PUSHD		;SAVE OUR POSITION ON STACK
	XCHG	DX,BX		;GET LIMIT VALUE
	CALL	PUSHD		;SAVE ON STACK
	XCHG	DX,BX		;GET POSITION BACK
	POP	AX		;GET INDEX VARIABLE NAME
;*
;* SAVES A SINGLE BYTE ENTRY ON THE USER (CONTROL) STACK
;*
PUSHS:	PUSH	BX		;SAVE H-L
	MOV	BX,[CSP]	;GET STACK POINTER
	MOV 	[BX],AL		;SAVE BYTE ON STACK
PSH1:
 	DEC	BX		;REDUCE POINTER
PSH2:	MOV	[CSP],BX	;RESAVE STACK POINTER
	POP	BX		;RESTORE H-L
	RET
;*
;* POP A SINGLE BYTE ENTRY FROM THE USER (CONTROL) STACK
;*
POPS:	PUSH	BX		;SAVE H-L
	MOV	BX,[CSP]	;GET STACK POINTER
	INC	BX		;ADVANCE TO NEXT ENTRY
	MOV 	AL,[BX]		;GET BYTE BACK
	JMP	PSH2		;SAVE POINTER AND CONTINUE
;*
;* PUSHES A DOUBLE BYTE ENTRY ON THE USER (CONTROL) STACK
;*
PUSHD:	PUSH	BX		;SAVE H-L
	MOV	BX,[CSP]	;GET STACK POINTER
	MOV 	[BX],DH		;SAVE HIGH BYTE
	DEC	BX		;BACK UP
	MOV 	[BX],DL		;SAVE LOW BYTE
	JMP	PSH1		;SAVE POINTER AND CONTINUE
;*
;* POPS A DOUBLE BYTE ENTRY FROM THE USER STACK
;*
POPD:	PUSH	BX		;SAVE H-L
	MOV	BX,[CSP]	;GET STACK POINTER
	INC	BX		;ADVANCE TO LAST ENTRY
	MOV 	DL,[BX]		;GET LOW BYTE
	INC	BX		;ADVANCE TO HIGH BYTE
	MOV 	DH,[BX]		;GET HIGH BYTE
	JMP	PSH2		;SAVE AND CONTINUE
;*
;* LET COMMAND, EVALUATE EXPRESSION
;*
LET:	CALL	EXPR		;EVALUATE EXPRESSION
	MOV	AL,[EFLAG]	;DID HE MAKE AN ASSIGNMENT?
	AND	AL,AL		;IF NOT..
	JZ 	SYNT		;HE'S MADE ANOTHER MISTAKE
	SUB	AL,AL		;RESET THE FLAG
	MOV	[EFLAG],AL	;SO WE KNOW WHEN HE SCREW'S UP AGAIN
	RET
;*
;* IT'S A NEXT COMMAND, TEST INDEX AGAINST LIMIT, AND LOOP IF NEEDED
;*
NEXT:	CALL	VCHAR		;TEST FOR VALID VARIABLE
	MOV 	CH,AL		;STASH IN B FOR SAFEKEEPING
	MOV	BX,[CSP]	;SAVE CONTROL STACK POINTER..
	MOV	[TEMP],BX	;IN CASE WE NEED TO LOOP AGAIN
	CALL	POPS		;GET VARIABLE NAME FROM STACK
	CMP	AL,CH		;TEST FOR WHAT HE GAVE US
	JNZ 	NSTERR	;IF NOT, HE'S SCREWED UP THE NESTING
	CALL	LOOK		;GET VARIABLE VALUE
	PUSH	DX		;SAVE POSITION
	CALL	POPD		;GET LIMIT FROM STACK
	;MOV 	CH,DH		;GET LIMIT
	;MOV 	CL,DL		;INTO B-C SO WE CAN 'COMP'
	MOV	CX,DX
	CMP	BX,CX		;TEST IF INDEX >= LIMIT
	JNC 	NOMORE	;IF SO, DON'T LOOP ANYMORE
	POP	DX		;GET POSITION BACK
	INC	BX		;INCREMENT LOOP INDEX
	MOV	BP,DX
	MOV	AL,[BP]		;GET VARIABLE NAME BACK
	CALL	STOR		;SAVE IT AWAY
	CALL	POPD		;GET NEW POSITION
	MOV	BX,[TEMP]	;GET CONTROL-STACK POINTER
	MOV	[CSP],BX	;AND REPLACE IT (LEAVING STACK UNCHANGED)
	RET
;* WE HAVE HIT THE END OF A FOR NEXT LOOP
NOMORE:	CALL	POPD		;CLEAN UP CONTROL STACK
	POP	DX		;GET PROGRAM COUNTER BACK
;*
;* REMARK, DO NOTHING, BUT RETURN, ALLOWING 'RNEXT' TO SKIP THE COMMAND
;*
REM:	RET
;*
;* IT'S AN 'IF' STATEMENT. FIND OUT 'IF' WE DO IT OR NOT
;*
IF:
 	DEC	DX		;BACK UP IN SOURCE
	MOV 	AL,DL		;GET LOW ADDRESS
	MOV	[P],AL		;SAVE IN POSITION POINTER
FTHEN:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,$0D		;IF IT'S A CARRIAGE RETURN..
	JZ 	SYNT		;THEN HE DIDN'T TYPE IN A 'THEN'
	INC	DX		;ADVANCE TO NEXT CHARACTER
	CMP	AL,'T'		;IS IT A 'T'?
	JNZ 	FTHEN	;IF NOT, IT AINT THE START OF 'THEN'
	MOV	BP,DX
	MOV	AL,[BP]		;GET NEXT CHARACTER
	CMP	AL,'H'		;TEST FOR NEXT CHARACTER OF 'THEN'
	JNZ 	FTHEN	;NO, MUST BE VARIABLE 'T' [OR HE CAN'T SPELL]
	DEC	DX		;BACK UP TO 'T'
	PUSH	DX		;SAVE POSITION IN SOURCE
	CALL	DOEXP		;EVALUATE CONDITION EXPRESSION
	POP	DX		;GET POSITION BACK
	MOV 	AL,BH		;GET RESULT AND TEST.
	OR	AL,BL		;IT FOR ZERO [FALSE]
	JZ	L86L7		;IF SO, SKIP THIS STATEMENT
	JMP	RLOOP		;EXECUTE THE 'THEN'
;*
;* LONG IF, CONTROLS REMAINDER OF ENTIRE LINE
;*
LIF:	CALL	IF		;CALCULATE AND PROCESS IF TRUE
LNXT:
 	INC	DX		;ADVANCE IN SOURCE
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,$0D		;TEST FOR END OF LINE
	JNZ 	LNXT		;KEEP LOOKING
L86L7:
	RET

;+
;* VIDEO INTERRUPT CALL
;+
VIDEO:	CALL	EXPR		;GET X COORDINATE
	JC	SYNT		;IF CHARACTER, IT'S NO GOOD
	MOV	AX,BX
	INT	10h
	RET

;+
;* EXIT BACK TO DOS - PASS RETURN VALUE FOR %errorlevel%
;+
EXIT:	CALL	EXPR		;GET X COORDINATE
	JC	SYNT		;IF CHARACTER, IT'S NO GOOD
	MOV	AL,BL
	MOV	AH,$4C
	INT	21h


;*
;* IT A 'PLOT' COMMAND, (HE'S PLOTTING AGAINST US)
;*
PLOT:	CALL	EXPR		;GET X COORDINATE
	JC	SYNT		;IF CHARACTER, IT'S NO GOOD
	PUSH	BX		;SAVE X COORDINATE
	INC	DX		;ADVANCE PAST ','
	CALL	EXPR		;GET Y COORDINATE
	INC	DX
	PUSH	BX
	CALL	EXPR		;GET COLOR
	MOV	AL,BL
	POP	BX
	POP	CX		;X
	PUSH	DX
	MOV	DX,BX		;Y

	MOV	AH,$0C		; Plot Pixel
	INT	10h
	
	POP	DX
	RET

	;JP	C,SYNT		;IF CHARACTER, IT'S NO GOOD
	;PUSH	HL		;SAVE X COORDINATE
	;INC	DE		;ADVANCE PAST ','
	;CALL	EXPR		;GET Y COORDINATE
	;POP	BC		;GET X POSITION IN B-C
	;ADD	HL,HL		;MULTIPLY.
	;ADD	HL,HL		;Y POSITION.
	;ADD	HL,HL		;BY 64.
	;ADD	HL,HL		;TO PLACE ADDRESS.
	;ADD	HL,HL		;ON PROPER LINE.
	;ADD	HL,HL		;OF THE DISPLAY
	;ADD	HL,BC		;ADD IN X POSITION
	;LD	BC,1024		;TEST AGAINST END OF SCREEN
	;CMP	BX,CX		;TO SEE IF WE ARE OVER
	;JP	NC,DIMERR	;IF SO, 'DIMENSION ERROR'
	;;;; CALL	CURPOS		;POSITION THE CURSOR
;* LOOK FOR END OF LINE, OR OTHER OPERANDS
	;CALL	SKIP		;GET NEXT SEPERATOR
	;CP	','		;TEST FOR COMMA
	;RET	NZ		;IF NOT, WE ARE DONE
	;INC	DE		;SKIP ','
;*
;* PRINT STATEMENT, LET'S OUTPUT SOMETHING SO HE WON'T GET UPSET
;* WHILE STAREING AT THE TUBE WONDERING IF WE DIED
;*
PRINT:	CALL	EXPR		;GET EXPRESSION TO PRINT
	PUSH	DX		;SAVE BASIC'S PROGRAM COUNTER
 
	JC	L86L8
	CALL	DECPRT	;IF NUMERIC, OUTPUT DECIMAL NUMBER
L86L8:
	POP	DX		;RESTORE BASIC'S PROGRAM COUNTER
 
	JNC	L86L9
	CALL	PV1		;IF CHARACTER, DISPLAY CHARACTER VALUE
L86L9:
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,','		;TEST FOR COMMA
	JNZ 	NEAR NL		;IF NOT, IT'S THE END
	CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
	JNZ 	PRINT	;PRINT NEXT EXPRESSION
L86L10:
	RET

;* PRINT CHARACTER EXPRESSIONS
PV1:	MOV	BX,XBF		;EXPRESSION IS IN EXTRA BUFFER
PZ:	MOV 	AL,[BX]		;GET CHARACTER FROM EXPRESSION
	INC	BX		;POINT TO NEXT
	AND	AL,AL		;TEST FOR END OF EXPRESSION
	JS	L86L10		;IF SO, END IT NOW
	CALL	OUTCH		;PRINT CHARACTER
	JMP	PZ		;KEEP GOING TILL END
;* RECURSIVE ROUTINE OUTPUTS NUMBER IN DECIMAL
DECPRT:	CMP	AL,'('		;TEST FOR SPECIAL CASE
 
	JZ	L86L11
	CALL	SPACE	;IF NOT, PRECEDE WITH SPACE
L86L11:
DECP1:	MOV	CX,10		;DIVIDE BY 10
	CALL	DODIV		;PERFORM DIVISION
	MOV 	AL,$030		;TO CONVERT TO ASCII
	ADD	AL,BL		;GET DIGIT
	PUSH	AX		;SAVE FOR OUTPUT
	XCHG	DX,BX		;SWAP, REMAINDER IS NOW IN HL
	MOV 	AL,BH		;GET HIGH BYTE
	OR	AL,BL		;TEST FOR ZERO, [FINISHED]
	JZ	L86L12
	CALL	DECP1	;IF NOT, GET NEXT VALUE
L86L12:
	POP	AX		;GET DIGIT OFF STACK
	JMP	OUTCH		;DISPLAY AND RETURN
;*
;* IT'S AN 'INPUT', LETS GIVE HIM A CHANCE TO DO SOME TYPING.. BUT
;* KEEP AN EYE ON HIM, IN CASE HE TRY'S TO PUT SOMETHING OVER ON US
;*
INPUT:	CALL	CLBF		;CLEAR EXTRA TEXT BUFFER
	MOV 	AL,'?'		;GET A QUESTION MARK.
	MOV	[XBF],AL		;TO USE AS THE DEFAULT PROMPT
	MOV	BP,DX
	MOV	AL,[BP]		;GET FIRST CHAR OF OPERAND
	CMP	AL,$22		;TEST FOR USER SUPPLIED PROMPT
	JNZ 	INP1		;IF NOT, DON'T CHANGE EXISTING ONE
	CALL	EXPR		;EVALUATE USER SUPPLIED PROMPT
	CALL	PARSE		;SKIP TO NEXT NON-BLANK
INP1:	CALL	VCHAR		;TEST FOR VALID VARIABLE NAME
	PUSH	DX		;SAVE SOURCE POSITION
	INC	DX		;ADVANCE TO NEXT CHARACTER
	PUSH	AX		;SAVE VARIABLE NAME
	MOV	BP,DX
	MOV	AL,[BP]		;GET NEXT CHARACTER
	CMP	AL,'$'		;TEST FOR CHARACTER INPUT
	JZ 	GCHR		;IF SO, GET CHARACTER DATA
	MOV	BX,0		;START WITH A ZERO
	ADD	BX,SP		;AND GET STACK POINTER. IN CASE WE BLOW UP
	MOV	[TEMP],BX	;SAVE SO WE CAN GET IT BACK LATER
RETRY:	CALL	PV1		;DISPLAY USER PROMPT
	SUB	AL,AL		;GET A ZERO
	MOV	[IFLAG],AL	;AND CLEAR THE INPUT FLAG (IN CASE HE CTRL-C'S)
	CALL	GLINE		;GET A LINE FROM THE TERMINAL
	MOV	[IFLAG],AL	;SET IFLAG. (SO GET ERROR, WE CAN COME BACK)
	CALL	EXPR		;EVALUATE EXPRESSION
	POP	AX		;RESTORE VARAIABLE NAME
	CALL	STOR		;STASH VALUE IN VARIABLE
	POP	DX		;RESTORE SOURCE POSITION
	SUB	AL,AL		;GET A ZERO
	MOV	[IFLAG],AL	;AND CLEAR IFLAG
	RET
;* CHARACTER INPUT
GCHR:	CALL	PV1		;DISPLAY USER PROMPT
	CALL	GLINE		;GET A LINE OF INPUT
	POP	AX		;GET VARIABLE BACK
	CALL	LTA		;GET THE TEXT VARIABLE'S ADDRESS
	MOV 	CH,35		;LENGTH IS 35
Z1:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM INPUT BUFFER
	CMP	AL,$0D		;TEST FOR END OF BUFFER
	JZ 	Z2		;IF SO, END THE LINE
	DEC	CH		;TEST FOR END OF VARIABLE SPACE
	JZ 	Z2		;IF SO, END THE LINE
	MOV 	[BX],AL		;SAVE IN VARIABLE SPACE
	INC	BX		;NEXT CHARACTER IN VARIABLE
	INC	DX		;NEXT CHARACTER IN INPUT BUFFER
	JMP	Z1		;COPY NEXT CHARACTER
Z2:	POP	DX		;RESTORE SOURCE POSITION
Z3:	MOV 	byte [BX],$0FF	;PAD BUFFER WITH NULL CHARACTERS
	INC	BX		;NEXT POSITION IN VARIABLE
	DEC	CH		;REDUCE COUNT TILL END
	JNS 	Z3		;KEEP GOING TILL VARIABLE IS FILLED
	RET
;*
;* LOOK'S LIKE HE CAN'T EVEN ENTER A SIMPLE NUMBER, CLEAN UP ANY STACK
;* HE MAY HAVE USED, AND LET HIM TAKE ANOTHER BLIND STAB AT THE KEYBOARD
;*
INERR:	MOV	BX,IERMS	;GET NASTY MESSAGE
	CALL	PMSG		;GIVE HIM THE BAD NEWS
	MOV	BX,[TEMP]	;GET HIS OLD STACK BACK
	MOV	SP,BX		;RESET HIS STACK
	JMP	RETRY		;LET HIM TRY AGAIN
;*
;* DIMENSION, HE WANTS SOME ARRAY SPACE.. I SUPPOSE WE SHOULD GIVE IT TO HIM
;*
DIM:	MOV 	AL,DL		;GET ADDRESS OF OUR POSITION
	MOV	[P],AL		;SAVE IN POSITION POINTER
DIM0:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	INC	DX		;ADVANCE TO NEXT
	CMP	AL,$0D		;TEST FOR END OF LINE
	JZ 	SYNT		;IF SO, TELL HIM TO STRAIGHTEN UP
	CMP	AL,')'		;TEST FOR START OF ARRAY DIMENSION
	JNZ 	DIM0		;IF NOT, KEEP LOOKING
	DEC	DX		;BACK UP FOR EXPRESSION
	PUSH	DX		;SAVE BASIC PROGRAM COUNTER
	CALL	DOEXP		;EVALUATE ARRAY SIZE
	INC	BX		;ADD ONE ENTRY (ZERO ENTRY DOES EXIST)
	ADD	BX,BX		;DOUBLE BECAUSE THEY ARE 16 BIT'S
	DEC	DX		;BACK UP TO NAME
	MOV	CX,BX
	;MOV 	CH,BH		;COPY SIZE NEEDED
	;MOV 	CL,BL		;INTO B AND C
	MOV	BX,[LAST]	;GET FREE ADDRESS
	PUSH	BX		;SAVE FOR TABLE
DLOOP:	MOV 	byte [BX],0		;ZERO ARRAY BYTE
	INC	BX		;ADVANCE TO NEXT
	DEC	CX		;REDUCE COUNT
	;MOV 	AL,CH		;GET HIGH BYTE OF REMAINING TO DO
	;OR	AL,CL		;TEST FOR NONE LEFT
	JNZ 	DLOOP	;IF NOT, KEEP ZEROING
	MOV	[LAST],BX	;SAVE NEXT FREE SPACE INDICATOR
	POP	BX		;GET ADDRESS OF ARRAY BACK
	MOV	BP,DX
	MOV	AL,[BP]		;GET ARRAY NAME
	CALL	TABENT		;GET TABLE ENTRY
	MOV 	AL,BH		;GET HIGH ADDRESS
	MOV	BP,CX
	MOV	[BP],AL		;PLACE IN TABLE
	INC	CX		;ADVANCE IN TABLE
	MOV 	AL,BL		;GET LOW ADDRESS
	MOV	BP,CX
	MOV	[BP],AL		;PLACE IN TABLE
	POP	DX		;GET SOURCE POSITION BACK
	CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
	JZ	L86L13
	CMP	AL,','		;TEST FOR ANOTHER OPERAND
	JZ 	DIM		;IF SO, KEEP GOING
	SUB	AL,AL		;CAUSE A SYNTAX ERROR BECAUSE WE ARE BAD
;*
;* LOCATES TABLE POSITION OF AN ARRAY
;*
TABENT:	CALL	VCHAR		;INSURE IT'S OK
	SUB	AL,'A'		;CONVERT TO BINARY
	ADD	AL,AL		;X 2 FOR TWO BYTE ENTRIES
	MOV 	CL,AL		;SAVE IN C
	MOV	AL,[ARYLOC]	;GET ARRAY PAGE
	MOV 	CH,AL		;SAVE IN HIGH ZBYTE
L86L13:
	RET
;* LOOKS UP AN ARRAY VALUE
ALOOK:	CALL	DOEXP		;CALCULATE INDEX VALUE
	DEC	DX		;BACK UP PAST '['
	MOV	BP,DX
	MOV	AL,[BP]		;GET VARIABLE NAME
	CALL	LOOKT		;FIND ADDRESS OF ENTRY
	MOV	CX,[BX]
	MOV	BH,CL
	MOV	BL,CH
	;MOV 	CH,[BX]		;GET HIGH BYTE OF ENTRY
	;INC	BX		;ADVANCE TO LOW BYTE
	;MOV 	CL,[BX]		;GET LOW BYTE OF ARRAY ENTRY
	;MOV 	BH,CH		;TRANSFER RESULT TO .
	;MOV 	BL,CL		;H AND L WHERE THEY ARE EXPECTED
	;MOV	BX,CX
	MOV	BP,DX
	MOV	AL,[BP]		;GET VARIABLE NAME BACK
	CMP	AL,'@'		;TEST FOR MAGIC 'PEEK' ARRAY
	JNZ	L86L14		;IF NOT, WE ARE OK
	MOV 	BL,BH		;SET VALUE TO THAT OF FIRST BYTE
	MOV 	BH,0		;AND ELIMINATE HIGH BYTE
L86L14:
	RET
;*
;* LOCATES ADDRESS OF AN ARRAY ENTRY IN THE ARRAY TABLE. INDEX IN HL
;*
LOOKT:	CMP	AL,'@'		;TEST FOR SPECIAL CASE
	JZ	L86L16		;IF SO, PEEK AT ADDRESS
	CALL	TABENT		;LOCATE TABLE ENTRY
	PUSH	DX		;SAVE BASIC PROGRAM COUNTER
	MOV	BP,CX
	MOV	AL,[BP]		;GET FIRST BYTE
	MOV 	DH,AL		;COPY TO HIGH BYTE
	INC	CX		;ADVANCE TO NEXT
	MOV	BP,CX
	MOV	AL,[BP]		;GET LOW BYTE
	MOV 	DL,AL		;COPY TO D
	ADD	BX,BX		;X TWO FOR TWO BYTE ENTRIES
	ADD	BX,DX		;ADD IN OFFSET FOR START OF ARRAY
	OR	AL,DH		;TEST FOR ADDRESS OF ZERO, = NOT DIMENSIONED
	POP	DX		;RESTORE PROGRAM COUNTER
	JNZ	L86L16		;NOT A DIMENSION ERROR, GO BACK
;*
;* EITHER HE'S TRIED TO INDEX A NON-ARRAY VARIABLE, TRIED TO INDEX A CHARACTER
;* VARIABLE WITH A VALUE GREATER THEN 34, OR HE'S PLOTTED OUTSIDE OF THE SCREEN
;* NO MATTER WHAT HE'S DONE, GIVE HIM A NASTY MESSAGE SO HE WON'T DO IT AGAIN
;*
DIMERR:	MOV	BX,OVM		;ADDRESS OF NASTY MESSAGE
	JMP	ERR		;GIVE IT TO HIM
;* LOCATES THE ADDRESS OF A CHARACTER (TEXT) VARIABLE
LTA:	SUB	AL,$041		;REDUCE TO SIMPLE BINARY
	CMP	AL,26		;TEST FOR VALID VARIABLE
	JNC 	SYNT		;IF NOT, GET MAD
	MOV	BX,VARS+25	;START OF CHARACTER VARIABLES [-37]
	MOV	CX,37		;LENGTH OF CHARACTER VARIABLES
V1:	ADD	BX,CX		;OFFSET INTO TABLE
	DEC	AL		;REDUCE VARIABLES WE HAVE TO GO
	JNS 	V1		;IF NOT FINISHED, KEEP OFFSETING
L86L16:
	RET
;*
;* IT'S A 'USR' COMMAND, FIND OUT WHAT HE WANT'S, PASS CONTROL  TO
;* HIS MACHINE LANGUAGE ROUTINE, AND GOD HELP HIM IF HE SCREW'S UP
;* BECAUSE WE CAN'T DO ANYTHING FOR HIM UNTIL HE RETURNS
;*
;USR:	MOV	BX,URET		;GET ON STACK [SO HE CAN 'RET' TO IT]
;	PUSH	BX		;SAVE IN MACHINE STACK
;	CALL	EXPR		;EVALUATE ADDRESS
;	PUSH	BX		;SAVE ON STACK (SO WE CAN 'RET' TO IT)
;	MOV	BP,DX
;	MOV	AL,[BP]		;GET NEXT CHARACTER
;	CMP	AL,','		;TEST FOR MORE PARAMETERS
;	JNZ 	CSAV		;IF NOT, DONT EVALUATE
;	INC	DX		;SKIP THE ','
;	CALL	EXPR		;EVALUATE PARAMETER TO PASS
;;* WHEN 'PUSHD' RETURNS, IT WILL EFFECT A JUMP TO HIS CODE
;CSAV:	JMP	PUSHD		;SAVE PROGRAM POSITION
;;* IF WE GET HERE, HE MADE IT BACK IN ONE PIECE
;URET:	CALL	POPD		;GET PROGRAM COUNTER BACK
;	MOV	BP,DX
;	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
;	CMP	AL,','		;TEST FOR VARIABLE TO RECEIVE H-L
; 
;	JZ	L86L17
;	RET  ;			;IF NOT, WE ARE DONE
;L86L17:
;	CALL	PARSE		;KEEP LOOKING


;*
;* EXECUTE EXTERNAL DOS COMMAND (MORE USEFUL THAN "USR" NOWADAYS)
;*
%ifdef EXTRA
EXEC:
	CALL	CLBF		;CLEAR EXTRA TEXT BUFFER
	CALL	EXPR		;GET TEXT EXPRESSION FOR COMMAND
	JNC	SYNT		;Must be a character expression
	
	MOV	BP,XBF-3

	PUSH	BP

	MOV	[BP],byte '/'
	INC	BP
	MOV	[BP],byte 'C'
	INC	BP
	MOV	[BP],byte ' '

	MOV	AL,$0FF		; BUFFER END
EXCLP:
	INC	BP
	CMP	[BP],AL
	JNZ	EXCLP
	MOV	[BP],byte 13	;CHANGE STRING TERMINATOR TO <CR>

	POP	AX
	
	MOV	BX,AX
	SUB	BP,AX
	MOV	AX,BP
	DEC	BX		;POINT TO XBF-4
	MOV	[BX],byte AL	;PUT TEXT LENGTH AT TOP
	
	CALL	PARSE
	CALL	VCHAR		;TEST FOR VALID VARIABLE NAME
	PUSH	DX
	PUSH	AX		;KEEP VARIABLE NAME
	
	
	mov	ax,cs
	mov	[cmdparm],ax	; update parameter pointer's segment
	
	;mov	ax,ss
	;mov	[ssstore],ax


	;; Request the system to free memory to 
	;; get the space to run the command
	;
	;mov	bx,4096		; 4096 * 16 = 64K
	mov	bx,$1001	; 64K+1 block, just to be sure
	mov     ah,4ah          ; Resize memory block
	int     21h		; ..keep only the current segment
				; so we can "shell to" other commands
	
	jc	DIMERR
	
	mov	ax,[STACK]
	mov	[sdsave],ax

	mov     dx,cmdname
	mov     bx,ExecStruct		;Ptr to program record.
	mov     ax,4b00h		;Exec pgm (AH=00 - LOAD AND EXECUTE)
	int     21h

	mov	ax,[sdsave]
	mov	[STACK],ax
	
; Before MS-DOS 6.0 maybe we had some register mess at this point (stack, etc..)

        mov     ax,cs
        mov     ss,ax
        mov	ds,ax
        mov	es,ax
        
        ;mov	ax,[ssstore]
        ;mov	[ssstore],ax

	JC	NPERR		;'NO PROGRAM' MESSAGE
	
	mov	ah,4dh		; Get return code
	int	21h
	mov	bx,ax
	
	;CALL	INCH
	;MOV	BH,0
	;MOV	BL,AL

	POP	AX
	POP	DX
	CALL	STOR		; PUT ASCII CODE IN INTEGER VALUE	
	RET


ExecStruct:
		dw	0
		dw	XBF-4	; offset for cmdline
cmdparm:	dw	0		; segment for cmdline
		dw	$0ffff,$0ffff
		dw	$0ffff,$0ffff

cmdname:        db	"c:\windows\system32\cmd.exe",0
;;cmdname:        db	"c:\windows\system32\command.com",0

;;;;cmdline:	db	10, "/C DIR abc", 0dh

sdsave:		dw	0
%endif

;*
;* STORES H-L INTO A INTEGER VARIABLE PASSED IN A
;*
STOR:	MOV 	CH,VARS/256	;GET ADDRESS OF VARIABLE TABLE
	SUB	AL,$041		;CONVERT TO BINARY
	CMP	AL,26		;TEST FOR VALID VARIABLE NAME
	JNC 	SYNT		;IF NOT, IT'S INVALID
	ADD	AL,AL		;DOUBLE BECAUSE THEY ARE 16 BIT ENTRIES
	MOV 	CL,AL		;PLACE IN C, MAKING COMPLETE ADDRESS
	MOV 	AL,BL		;GET HIGH VALUE TO SAVE
	MOV	BP,CX
	MOV	[BP],AL		;SAVE IN VARIABLE
	INC	CX		;NEXT BYTE OF VARIABLE
	MOV 	AL,BH		;GET LOW BYTE
	MOV	BP,CX
	MOV	[BP],AL		;SAVE IN VARIABLE
	RET
;*
;* RETERIVES CONTENTS OF A VARIABLE
;*
LOOK:	MOV 	CH,VARS/256		;ADDRESS OF VARIABLES
	SUB	AL,$041		;CONVERT NAME TO BINARY
	ADD	AL,AL		;DOUBLE FOR 16 BIT ENTRIES
	MOV 	CL,AL		;MAKE COMPLETE ADDRESS
	MOV	BP,CX
	MOV	AL,[BP]		;GET HIGH BYTE
	MOV 	BL,AL		;PLACE IN H
	INC	CX		;NEXT BYTE OF VARIABLE
	MOV	BP,CX
	MOV	AL,[BP]		;GET LOW BYTE
	MOV 	BH,AL		;PLACE IN L
	RET
;*
;* IT'S AN 'ORDER', (HE THINKS HE KNOWS WHERE THERE IS SOME DATA)
;*
ORDER:	PUSH	DX		;SAVE OUR SOURCE POSITION
	CALL	FNDLIN		;GET ADDRESS OF THE LINE HE WANTS
	POP	DX		;RESTORE OUR POSITION
	PUSH	DX		;AND RESAVE OUR POSITION
	JNZ 	BADLIN	;IF IT DOSN'T EXIST, THEN FORGET IT
	INC	BX		;SKIP FIRST TWO DIGITS OF LINE NUMBER
	INC	BX		;SKIP LAST TWO DIGITS OF LINE NUMBER
	INC	BX		;SKIP LENGTH BYTE
	XCHG	DX,BX		;MOVE TO D-E
	CALL	VERDAT		;GET STATEMENT FROM LINE
	MOV	[DATA],BX	;SAVE DATA POINTER
	POP	DX		;RESTORE OUR LINE, (SO WE CAN TELL HIM)
	JZ	near L86L19
;*
;* DATA ERROR... ATTEMPT TO READ FROM A LINE WITHOUT 'DATA' OR
;* ATTEMPT TO READ THE WRONG DATA TYPE. LET HIM IN ON IT
;*
DERR:	MOV	BX,DTXT		;ADDRESS OF 'DATA' MESSAGE
	JMP	SYNT+3		;DISPLAY IT
;*
;* IT'S A READ. (HE WANTS TO KNOW WHATS IN THAT DATA WE FOUND)
;*
READ:	CALL	VCHAR		;IS IT A VALID VARIABLE
	PUSH	AX		;SAVE VARIABLE NAME
	INC	DX		;ADVANCE TO NEXT CHARACTER
	MOV	BP,DX
	MOV	AL,[BP]		;GET NEXT CHARACTER
	CMP	AL,'$'		;IS IT A CHARACTER VARIABLE?
	JZ 	CDAT		;IF SO, LOOK FOR CHARACTER DATA
;* NUMERIC DATA, FOR NUMERIC VARIABLE
	CALL	GETDAT		;GET NUMERIC DATA
	JC 	DERR		;IF CHARACTER, IT A DATA TYPE ERROR
	POP	AX		;GET VARIABLE NAME BACK
	CALL	STOR		;STASH VALUE IN IT
	JMP	MORDAT		;SEE IF HE WANT'S MORE DATA
;* CHARACTER DATA, FOR CHARACTER VARIABLE
CDAT:
 	INC	DX		;SKIP DOLLAR SIGN
	CALL	GETDAT		;GET DATA
	JNC 	DERR		;IF NUMERIC, IT'S BAD
	POP	AX		;GET VARIABLE NAME BACK
	CALL	LTA		;FIND IT'S ADDRESS
	MOV	CX,XBF		;DATA IS IN EXTRA BUFFER
	PUSH	DX		;SAVE SOURCE POSITION
	MOV 	DL,35		;MOVE 35 CHARACTERS
SL1:
	MOV	BP,CX
 	MOV	AL,[BP]		;GET CHARACTER FROM BUFFER. {DATA}
	MOV 	[BX],AL		;STASH IT IN THE VARIABLE
	INC	CX		;SKIP TO THE NEXT CHARACTER IN THE BUFFER
	INC	BX		;SKIP TO THE NEXT POSITION IN VARIABLE
	DEC	DL		;REDUCE COUNT OF HOW MANY TO MOVE
	JNZ 	SL1		;IF NOT FINISHED, KEEP COPYING
	POP	DX		;RESTORE SOURCE POSITION
;* LOOK FOR MORE VARIABLES (OPERANDS) IN THE 'READ' STATEMENT
MORDAT:	CALL	PARSE1		;FIND NEXT NON-BLANK
	CMP	AL,','		;IF COMMA..
	JNZ	L86L19		;IF NOT, WE HAVE ALL THERE IS
	CALL	PARSE		;SKIP COMMA AND FIND VARIABLE NAME
	JMP	READ		;GET MORE DATA FOR FOLLOWING VARIABLE
;* GETS DATA FROM THE DATA STATEMENTS, POINTED TO BY THE CURRENT READ POINTER
GETDAT:	MOV	BX,[DATA]	;GET DATA POINTER
	MOV 	AL,BH		;SEE IF IT IS ZERO.
	OR	AL,BL		;WHICH INDICATES THAT IT WASN'T INITIALIZED
	JZ 	DERR		;IF SO, IT'S A DATA ERROR
	PUSH	DX		;SAVE SOURCE POSIITION
	XCHG	DX,BX		;SWAP DATA POINTER TO D-E
	CALL	EXPR		;EVALUATE THE DATA EXPRESSION
	LAHF
	PUSH	AX		;SAVE THE CONDITION FLAGS
ENDAT:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET NEXT CHARACTER FROM THE SOURCE
	CMP	AL,','		;TEST FOR MORE DATA
	JZ 	COMA		;IF SO, WE ARE OK
	CMP	AL,':'		;TEST FOR END OF STATEMENT
	JZ 	DAT1		;GO TO NEXT DATA STATEMENT
	INC	DX		;ADVANCE ONE CHARACTER
	CMP	AL,$0D		;CARRIAGE RETURN?
	JNZ 	ENDAT	;KEEP LOOKING IF NOT
;* HIT THE END OF A LINE, SKIP TO NEXT DATA STATEMENT
	INC	DX		;SKIP FIRST TWO DIGITS
	INC	DX		;SKIP SECOND TWO DIGITS
DAT1:
 	INC	DX		;SKIP LENGTH (OR ':' IF STMT)
	PUSH	BX		;SAVE H-L REG
	CALL	VERDAT		;CHECK FOR DATA STATEMENT
	XCHG	DX,BX		;SWAP POINTER BACK TO D-E
	POP	BX		;RESTORE REGISTERS
	JZ 	GDEND		;RETURN, WITH NEW DATA POINTER
	MOV	DX,$0FFFF	;INDICATE NO MORE DATA STATEMENTS
COMA:
 	INC	DX		;SKIP THE COMMA
GDEND:	XCHG	DX,BX		;SWAP DATA POINTER BACK TO H-L
	MOV	[DATA],BX	;SAVE IN POINTER
	XCHG	DX,BX		;SWAP VALUE BACK TO H-L
	POP	AX		;GET FLAGS BACK
	SAHF
	POP	DX		;GET SOURCE POSITION BACK
L86L19:
	RET
;*
;* VERIFY THAT COMMAND WAS 'DATA'
;*
VERDAT:	CALL	PARSE1		;SKIP TO COMMAND
	XCHG	DX,BX		;SWAP TO H-L
	MOV	DX,DATCMD	;POINT TO DATA COMMAND
VER1:	MOV 	AL,DL		;GET LOW ADDRESS
	CMP	AL,DATCMD+4	;ARE WE AT END
	JZ	L86L20
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHR FROM TABLE
	INC	DX		;ADVANCE TO NEXT
	AND	AL,$07F		;INSURE IT'S CORRECT
	CMP	AL,[BX]		;DUZ IT MATCH?
	LAHF
	INC	BX		;NEXT IN DATA COMMAND
	SAHF
	JZ 	VER1		;OK, TEST NEXT
L86L20:
	RET
;*
;* HE WANT'S TO KNOW HOW BIG IT IS... LETS FIGURE IT OUT AND LET HIM IN ON IT
;*
SIZE:	PUSH	DX		;SAVE PROGRAM POINTER
	CALL	GETEOF		;FIND THE END OF THE FILE
	MOV	CX,65536-TEXT	;GET THE [NEGATIVE] FILE START ADDRESS
	ADD	BX,CX		;SUBTRACT FILE START FROM FILE END
	CALL	DECPRT		;DISPLAY VALUE IN DECIMAL
	MOV	BX,SIMSG	;GET ' BYTES' MESSAGE
	POP	DX		;RESTORE PROGRAM POINTER
	JMP	PMSG		;TELL HIM WHAT IT IS
;* FINDS THE END OF THE FILE, HL=LAST BYTE OF PGM., A=FIRST FREE PAGE
GETEOF:	MOV	BX,TEXT		;START AT THE BEGINING
	MOV 	AL,255		;LOOKING FOR AN FF
GLPX:	CMP	AL,[BX]		;IS THIS IT?
	JZ	EOFOUND
	INC	BX		;ADVANCE TO NEXT
	JMP	GLPX		;KEEP LOOKING
EOFOUND:
	MOV 	AL,BH		;GET HIGH VALUE
	INC	AL		;ADVANCE TO NEXT PAGE
	RET
;*
;* HE'S TRYING TO 'LOAD' SOMETHING, I WONDER IF HE HAS SOMETHING SAVED..
;*
LOAD:	push	dx
	mov	al,0		; READ MODE
	mov	dx,filename	; POINTER TO FILE NAME
	mov	ah,$3d		; OPEN FILE
	int	$21
	jnc	found
NPERR:
	MOV	BX,NP		;AND ADDRESS OF 'NO PROGRAM' MESSAGE
	JMP	ERR

found:	
	mov	bx,ax		; file handle
	push	ax
	
	mov	dx,TEXT		; POINT TO PROGRAM
	mov	cx,65535-TEXT
	mov	ah,$3f
	int	$21
	
	pop	bx		; file handle
	mov	ah,$3e		; close file
	int	$21

	pop	dx
	ret
	;JP	RESV		;CLEAR VARIABLES AND GET A NEW COMMAND


filename: db "PROGRAM.BAS", 0
;;handle:   dw ?


;	JMP	short SYNT		;;;;

;	CALL	TON		;TURN ON TAPE AND WAIT
;.LOD1	CALL	GETR		;GET A RECORD
;	JP	C,LOD1		;KEEP GOING TILL WE HAVE IT ALL
;	CALL	TOFF		;SHUT TAPE OFF
;	JP	RESV		;CLEAR VARIABLES AND GET A NEW COMMAND

;*
;* HE'S TRYING TO 'SAVE' SOMETHING..
;*
SAVE:
	PUSH	DX		;SAVE PROGRAM POINTER
	MOV	BX,TEXT
	MOV	AL,[BX]		;GET FIRST BYTE
	INC	AL		;TEST FOR NO PROGRAM
	JZ	RUN		;IF SO, RUN WILL ABORT WITH ERROR
	
	MOV	DX,BX
	CALL	GETEOF		;GET ENDING ADDRESS
	MOV	CX,65536-TEXT+1	;GET THE [NEGATIVE] FILE START ADDRESS
	ADD	BX,CX		;SUBTRACT FILE START FROM FILE END
	;;INC	BX
	
	PUSH	BX
	
	mov	cx,16		; NORMAL MODE
	mov	dx,filename	; POINTER TO FILE NAME
	mov	ah,$3c		; CREATE FILE
	int	$21
	jnc	created
	JMP	short NPERR		; 'NO PROGRAM' MESSAGE

created:
	mov	bx,ax		; file handle

	mov	dx,TEXT		; POINT TO PROGRAM
	POP	CX		; program length

	push	ax		; file handle

	mov	ah,$40
	int	$21

	pop	bx		; file handle
	mov	ah,$3e		; close file
	int	$21

	POP	DX		;RESTORE PROGRAM POINTER
	RET


;	JMP	short SYNT		;;;;

;	PUSH	DE		;SAVE PROGRAM POINTER
;	LD	DE,TEXT		;GET ADDRESS OF TEXT
;	LD	A,(DE)		;GET FIRST BYTE
;	INC	A		;TEST FOR NO PROGRAM
;	JP	Z,RUN		;IF SO, RUN WILL ABORT WITH ERROR
;	CALL	GETEOF		;GET ENDING ADDRESS
;	CALL	TDUMP		;DUMP PROGRAM AND RETURN
;	POP	DE		;RESTORE PROGRAM POINTER
;	RET

;*
;*****************************************************************
;*                 EXPRESSION EVALUATION CODE
;*****************************************************************
;*
;* EVALUATES 16 BIT DECIMAL NUMBERS
;*
EVAL:	MOV	CX,1		;MULTIPLIER IS ONE
	MOV 	BH,CH		;INITIALIZE
	MOV 	BL,CH		;STARTING RESULT TO ZERO
ETOP:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET DIGIT FROM SOURCE
	CALL	NUM		;TEST FOR INVALID DIGIT
	JC	L86L22		;IF SO, WE ARE FINISHED
	AND	AL,$0F		;CONVERT TO BINARY
;* ADD A,DIGIT TIMES MULTIPLIER IN B-C TO H-L
ZLOOP:	DEC	AL		;REDUCE BY ONE
	JS 	ESP1		;EXIT WHEN EXAUSTED
	ADD	BX,CX		;ADD MULTIPLIER
	JMP	ZLOOP		;CONTINUE TILL DONE
;* MULTIPLY MULTIPLIER (BC) BY 10
ESP1:
	;PUSH	BX
	MOV	BP,CX
	ROL	CX,2		;*4
	ADD	CX,BP		;*5
	ADD	CX,CX		;*10
	;POP	BX

	DEC	DX		;REDUCE POINTER IN SOURCE
	JMP	ETOP		;EVALUATE NEXT CHARACTER
;*
;* SUBROUTINE TESTS FOR VALID ASCII CHARACTERS
;*
FNCHAR:	CMP	AL,'A'		;TEST FOR < 'A'
	JC	L86L22		;RETURN SAYING IT'S BAD
	CMP	AL,'['		;TEST FOR >'Z'
	CMC			;INVERT LOGIC
L86L22:
	RET
;*
;* PARSES FORWARD, SEARCHING FOR FIRST NON-BLANK CHARACTER
;*
PARSE:
 	INC	DX		;ADVANCE IN SOURCE
PARSE1:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,' '		;TEST FOR SPACE
	JZ 	PARSE		;KEEP LOOKING
	CMP	AL,':'		;TEST FOR END OF STATEMENT
	JZ	L86L23
	CMP	AL,$0D		;TEST FOR END OF LINE
L86L23:
	RET			;RETURN WITH Z SET

;*
;* SKIPS TO NEXT EXPRESSION OR COMMAND
;*
SKIP:	CALL	PARSE1		;ADVANCE TO NEXT NON-BLANK
	DEC	DX		;BACK UP TO POSITION
	MOV 	AL,DL		;GET LOW ORDER ADDRESS
	MOV	[P],AL		;SAVE IN POSITION BYTE
;* LOOK FOR DELIMITER
SKIP1:
 	INC	DX		;ADVANCE TO NEXT
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER
	CMP	AL,':'		;TEST FOR DELIMITER
	JZ	L86L23
	CMP	AL,','		;TEST FOR DELIMITER
	JZ	L86L23
	CMP	AL,$0D		;TEST FOR DELIMITER
	JZ	L86L23
	CMP	AL,$22		;TEST FOR QUOTE
	JNZ	L86L27
	CALL	SKPQUO		;IF SO, ADVANCE TO NEXT QUOTE
L86L27:
	JMP	SKIP1		;KEEP LOOKING
;* FIND NEXT QUOTE IN SOURCE
SKPQUO:
 	INC	DX		;ADVANCE TO NEXT CHARACTER IN SOURCE
	MOV	BP,DX
	MOV	AL,[BP]		;GET THE CHARACTER
	CMP	AL,$22		;IS IT A QUOTE?
	JZ	L86L23		;IF SO, WE FOUND IT
	CMP	AL,$0D		;IF IT A CARRIAGE RETUEN
	JNZ 	SKPQUO		;IF NOT, OK
	JMP	SYNT		;UNMATCHED QUOTES WHILE PARSING
;*
;* EVALUATES AN EXPRESSION POINTED TO BY D-E. RETURN WITH CARRY SET
;* INDICATES THAT EXPRESSION WAS A CHARACTER EXPRESSION
;*
EXPR:	CALL	SKIP		;ADVANCE TO END OF EXPRESSION
	PUSH	DX		;SAVE POINTER TO END
	CALL	DOEXP		;EVALUATE
	POP	DX		;RESTORE POINTER TO END OF EXPRESSION
	RET
;* CALCULATES EXPRESSION BACKWARDS (LIKE APL)
DOEXP:
 	DEC	DX		;BACK UP IN SOURCE
	CALL	FE		;GET CHARACTER FROM SOURCE
	CMP	AL,'$'		;TEST FOR CHARACTER VARIABLE
	JZ 	NEAR CEXP		;IF SO, ITS A CHARACTER EXPRESSION
	CMP	AL,$22		;TEST FOR QUOTE
	JZ 	NEAR CEXP		;IF SO, IT'S A CHARACTER EXRESSION
	INC	DX		;ADVANCE
	MOV 	AL,';'		;NULL OPERATOR TO START
EGO1:	PUSH	BX		;SAVE OLD VALUE
	PUSH	AX		;SAVE OPERATOR
	DEC	DX		;BACK UP TO VALUE
	CALL	FE		;GET CHARACTER FROM SOURCE
	CMP	AL,')'		;TEST FOR BRACKET
	JZ 	BRKTS		;IF SO, RECURSE
	CMP	AL,']'		;TEST FOR ARRAY LOOKUP
	JZ 	ARYL		;IF SO, LOOK UP ARRAY VALUE
	CALL	FNCHAR		;TEST FOR VARAIABLE
	JNC 	LOOKU		;IF SO, LOOK IT UP
	CMP	AL,'?'		;TEST FOR RANDOM NUMBER RETERIVAL
	JZ 	NEAR RANDR		;GET RANDOM VALUE
	CMP	AL,'#'		;TEST FOR HEX CONSTANT
	JZ 	HEXVL		;IF SO, GET HEV VALUE
	CALL	NUM		;TEST FOR A NUMBER
	JC 	SYNT		;IF NOT, I DON'T KNOW WHAT HE'S DOING
;* DECIMAL NUMBER
CALN:	CALL	EVAL		;EVALUATE DECIMAL NUMBER
	JMP	OLOOK		;LOOK FOR OPERATOR
;* HEX. NUMBER
HEXVL:
 	DEC	DX		;BACK UP IN SOURCE
	MOV	AL,[P]		;GET ENDING POSITION
	CMP	AL,DL		;TEST FOR PASSED THE LIMIT
	JZ 	HEXGO		;IF SO, THATS IT
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CALL	NUM		;TEST FOR VALID DIGIT
	JNC 	HEXVL	;KEEP GOING TILL WE GET TO START OF STRING
	SUB	AL,'A'		;TEST FOR VALID LETTER
	CMP	AL,6		;OF 'A' TO 'F'
	JC 	HEXVL		;IF SO, KEEP LOOKING
HEXGO:	MOV	BX,0		;START WITH A ZERO
	MOV 	CH,BH		;FLAG TO SEE IF ANY DIGITS
	PUSH	DX		;SAVE POSITION IN SOURCE
GETHX:
 	INC	DX		;ADVANCE TO NEXT DIGIT OF HEX NUMBER
	MOV	BP,DX
	MOV	AL,[BP]		;GET DIGIT
	CMP	AL,'#'		;TEST FOR END OF STRING
	JZ 	HGON		;IF SO, WE ARE DONE
	MOV 	CH,AL		;SET FLAG SO WE KNOW WE GOT AT LEAST ONE DIGIT
	ADD	BX,BX		;SHIFT H-L
	ADD	BX,BX		;RIGHT IN ORDER
	ADD	BX,BX		;TO MAKE ROOM FOR
	ADD	BX,BX		;THE NEW DIGIT
	SUB	AL,'0'		;REDUCE TO BINARY
	CMP	AL,10		;TEST FOR FURTHER REDUCTION NEEDED
	JC 	HISG		;IF NOT, PROCESS
	SUB	AL,7		;CONVERT LETTER TO BINARY
HISG:	OR	AL,BL		;ADD IN BOTTOM DIGIT OF RESULT
	MOV 	BL,AL		;REPLACE IN RESULT
	JMP	GETHX		;GET NEXT DIGIT
HGON:	POP	DX		;GET POSITION IN SOURCE BACK
	MOV 	AL,CH		;GET FLAG
	AND	AL,AL		;TEST FOR DIGIT'S PROCESSED
	JNZ 	OLOOK	;NO PROBLEM
	JMP	SYNT		;'#' WITH NO DIGITS... ERROR
;* A ')' HAS BEEN DETECTED
BRKTS:	CALL	DOEXP		;RECURSE ON OURSELVES
	JMP	DCLB		;CONTINUE WITH VALUE
;* LOOK UP AN ARRAY VALUE
ARYL:	POP	AX		;GET OPERATOR BACK
	PUSH	AX		;STASH OPERATOR
	CMP	AL,'='		;TEST FOR ASSIGNMENT
 
	JZ	L86L29
	CALL	ALOOK	;IF NOT, GET VALUE
L86L29:
	JMP	DCLB		;CONTINUE WITH VALUE
;* GET VARIABLE CONTENTS
LOOKU:	CALL	LOOK		;LOOK UP VALUE OF VARIABLE
DCLB:
 	DEC	DX		;BACK UP IN SOURCE
OLOOK:	POP	AX		;GET OPERATOR BACK
	POP	CX		;GET OLD VALUE BACK
;* 16 BIT ADDITION
	CMP	AL,'+'		;TEST FOR ADDITION
	JZ 	FNADD		;IF SO, PERFORM ADD
;* SIXTEEN BIT SUBTRACTION
	CMP	AL,'-'		;TEST FOR SUBTRACTION
	JNZ 	FNMULT	;NO, TRY MULTIPLICATION
	MOV 	AL,CH		;GET B
	NOT	AL			;COMPLEMENT
	MOV 	CH,AL		;RESAVE
	MOV 	AL,CL		;GET C
	NOT	AL			;COMPLEMENT
	MOV 	CL,AL		;RESAVE
	INC	CX		;ADD 1 GIVING TWO'S COMPLEMENT
FNADD:	ADD	BX,CX		;ADD TO NEW VALUE
	JMP	EGO		;CONTINUE
;* 16 BIT MULTIPLICATION
FNMULT:	CMP	AL,'*'		;TEST FOR MULTIPLY
	JNZ 	FNDIV		;NO, TRY DIVIDE
	;MOV 	AL,CH		;TEST OLD VALUE FOR ZERO
	;OR	AL,CL		;AS IT IS A
	;JZ 	NEAR EGZ		;SPECIAL CASE
	CALL	DMULT		;PERFORM THE MULTIPLY
	JMP	EGO		;AND CONTINUE
;* MULTIPLY SUBROUTINE (ALSO USED BY RANDOM NUMBER GENERATOR)
DMULT:	PUSH	DX		;SAVE POSITION IN SOURCE
	MOV	AX,BX
	MOV	DX,0
	IMUL	CX
	MOV	BX,AX
	POP	DX		;RESTORE SOURCE POSITION
	RET


;DMULT:	PUSH	DX		;SAVE POSITION IN SOURCE
;	MOV	DX,0		;START OUT WITH A ZERO
;MUL1:	AND	AL,AL		;INSURE CARRY CLEAR
;	MOV 	AL,CH		;GET B
;	RCR	AL,1			;ROTATE
;	MOV 	CH,AL		;RESAVE
;	MOV 	AL,CL		;GET C
;	RCR	AL,1			;ROTATE WITH CARRY
;	MOV 	CL,AL		;REPLACE
;	LAHF
;	PUSH	AX		;SAVE FLAGS
;	OR	AL,CH		;TEST FOR B-C = ZER0
;	JZ 	MEXIT		;IF SO, WE ARE DONE
;	POP	AX		;GET FLAGS BACK
;	SAHF
;	JNC 	NOMAD	;NO ONE BIT, DON'T ADD
;	XCHG	DX,BX		;SWAP SO WE CAN
;	ADD	BX,DX		;ADD TO D-E
;	XCHG	DX,BX		;AND SWAP BACK
;NOMAD:	ADD	BX,BX		;SHIFT H-L RIGHT BY ONE BIT
;	JMP	MUL1		;KEEP GOING
;MEXIT:	ADD	BX,DX		;ADD RESULT
;	POP	AX		;CLEAN UP STACK
;	SAHF
;	POP	DX		;RESTORE SOURCE POSITION
;	RET


;* 16 BIT DIVISION
FNDIV:	CMP	AL,'%'		;TEST FOR DIVIDE
	JNZ 	FLOR		;NO, TRY FLOR
	MOV 	AL,CH		;TEST FOR AN OLD
	OR	AL,CL		;VALUE OF ZERO,
	JZ 	DIVZE		;BECAUSE THAT IS  A BAD THING
	PUSH	DX		;SAVE SOURCE POSITION
	CALL	DODIV		;PERFORM DIVIDE OPERATION
	MOV	[VARS+34],BX	;SET 'R' REMAINDER VARIABLE
	XCHG	DX,BX		;PLACE RESULT IN H-L
	POP	DX		;RESTORE SOURCE POSITION
	JMP	EGO		;AND CARRY ON
;*
;* PERFORMS 16 BIT(HL) BY 16 BIT(BC) DIVIDE, RESULT IN DE, REM IN HL
;*
; DX:AX is divided by "src" and the quotient is stored in AX and the remainder in DX.

DODIV:	MOV	AX,BX
	MOV	DX,0
	;IDIV	CX
	DIV	CX
	MOV	BX,DX
	MOV	DX,AX
	RET


;DODIV:	MOV 	AL,CH		;GET CONTENTS OV B
;	NOT	AL		;;INVERT
;	MOV 	CH,AL		;REPLECE
;	MOV 	AL,CL		;GET CONTENTS IN C
;	NOT	AL		;;INVERT
;	MOV 	CL,AL		;REPLACE
;	LAHF
;	INC	CX		;COMPLETE TWO COMPLEMENT OPERATION
;	SAHF
;	XCHG	DX,BX		;COPY HL TO DE, LOWER HALF OF 32 BIT VALUE
;	MOV	BX,0		;ZERO HIGHER HALF
;	CALL	DIVBYT		;PERFORM FIRST HALF
;DIVBYT:	MOV 	AL,DH		;GET UPPER HALF
;	MOV 	DH,DL		;SAVE LOWER HALF
;	MOV 	DL,8		;GET LOOP COUNT
;DIVTOP:	ADD	BX,BX		;SHIFT LEFT
;	JC 	OVER1		;OVERFLOWED
;	ADD	AL,AL		;SHIFT  RESULT
;	JNC 	SUBB		;IF NO CARRY, DON'T INC
;	LAHF
;	INC	BX		;ADVANCE UPPER VALUE
;	SAHF
;SUBB:	PUSH	BX		;SAVE VALUE
;	ADD	BX,CX		;SUBTRACT LOWER HALF OF FRACTION
;	JC 	OKKK		;IF WRAP PAST ZERO
;	POP	BX		;RESTORE VALUE
;	JMP	NXLP		;FINISH LOOP
;OKKK:	INC	SP		;FIX UP
;	INC	SP		;STACK
;	INC	AL		;ADVANCE RESULT
;	JMP	NXLP		;FINISH LOOP
;OVER1:	ADC	AL,AL		;SHIFT RESULT, +1 FOR CARRY
;	JNC 	OVRSUB	;IF NO WRAP
;	LAHF
;	INC	BX		;INC. VALUE
;	SAHF
;OVRSUB:	ADD	BX,CX		;SUBTRACT LOWER
;NXLP:	DEC	DL		;REDUCE LOOP COUNTER
;	JNZ 	DIVTOP	;LOOP IF NOT FINISHED
;	MOV 	DL,AL		;LOWER BYTE OF RESULT
;	RET


;*
;* HE SHOULD KNOW THAT HE CAN'T DIVIDE BY ZERO, BUT JUST IN CASE...
;* WE WILL TELL HIM ANYWAY
;*
DIVZE:	MOV	BX,DER		;ADDRESS OF 'DIVIDE BYE ZERO MESSAGE'
	JMP	ERR		;HANDLE LIKE ANY OTHER ERROR
;* COMPARES H-L TO B-C, Z=1 IF HL=BC, C=1 IF HL<BC
;COMP:	MOV 	AL,BH		;GET HIGH BYTE OF HL
;	CMP	AL,CH		;COMPARE WITH HIGH BYTE OF BC
; 
;	JZ	L86L30
;	RET  ;			;IF NOT SAME, LOWER BYTE CAN BE IGNORED
;L86L30:
;	MOV 	AL,BL		;GET LOW BYTE OF HL
;	CMP	AL,CL		;COMPARE WITH LOW BYTE OF BC
;	RET
;* FLOOR, RETURNS THE LESSER OF THE TWO NUMBERS
FLOR:	CMP	al,'\'		;IS IT FLOOR?   ####
	JNZ 	CEIL		;NO, TRY CEILING
	CMP	BX,CX		;COMPARE NEW TO OLD
	JC 	NEAR EGO		;IF LESS, WE ARE OK [RESULT IS ALREADY IN HL]
SWAP:	;MOV 	BH,CH		;MAKE OLD NUMBER..
	;MOV 	BL,CL		;INTO THE NEW NUMBER..
	MOV	BX,CX
	JMP	EGO		;CONTINUE
;* CEILING, RETURNS THE GREATER OF THE TWO NUMBERS
CEIL:	CMP	AL,'/'		;IS IT CEILING?
	JNZ 	LAND		;NO, TRY LOGICAL AND
	CMP	BX,CX		;COMPARE NEW AND OLD
	JNC 	NEAR EGO		;IF GREATER, WE ARE OK [RESULT ALREADY IN HL]
	JMP	SWAP		;MAKE OLD NEW AND CONTINUE
;* LOGICAL AND
LAND:	CMP	AL,'&'		;IF IT LOGICAL AND ?
	JNZ 	LOR		;NO, TRY LOGICAL OR
	AND	BX,CX
	JMP	EGO
	;MOV 	AL,CH		;GET HIGH BYTE OF OLD
	;AND	AL,BH		;AND WITH HIGH BYTE OF NEW
	;MOV 	BH,AL		;AND REPLACE HIGH BYTE OF NEW
	;MOV 	AL,BL		;GET LOW BYTE OF OLD
	;AND	AL,CL		;AND WITH LOW BYTE OF NEW
	;JMP	CPYL		;CONTINUE
;* LOGICAL OR
LOR:	CMP	AL,'|'		;TEST FOR LOGICAL OR
	JNZ 	GRTR		;NO, TRY GREATER THAN
	OR	BX,CX
	JMP	EGO
	;MOV 	AL,BH		;GET HIGH BYTE OF NEW
	;OR	AL,CH		;OR WITH HIGH BYTE OF OLD
	;MOV 	BH,AL		;AND REPLACE HIGH BYTE OF NEW
	;MOV 	AL,BL		;GET LOW BYTE OF NEW
	;OR	AL,CL		;OR WITH LOW BYTE OF OLD
;CPYL:	MOV 	BL,AL		;AND REPLACE LOW BYTE OF NEW
	;JMP	EGO		;CONTINUE
;* GREATER THAN, RETURNS ONE OR ZERO
GRTR:	CMP	AL,'>'		;TEST FOR GREATER THAN
	JNZ 	LETH		;IF NOT, TRY LESS THAN
	CMP	BX,CX		;COMPARE OLD AND NEW
	JZ 	NEAR EGZ		;FALSE IF EQUAL
	JC 	NEAR EGZ		;FALSE IF LESS THAN
	JMP	EG1		;TRUE IF NOT LESS OR EQUAL
;* LESS THAN, RETURNS ONE OR ZERO
LETH:	CMP	AL,'<'		;IS IT LESS THAN?
	JNZ 	ENOP		;NO, TRY NO-OP OPERATOR
	CMP	BX,CX		;COMPARE OLD AND NEW
	JC 	NEAR EG1		;TRUE IF LESS
	JMP	EGZ		;FALSE IF NOT LESS
;* NO-OP OPERATOR, RETURNS NEW VALUE ONLY
ENOP:	CMP	AL,';'		;IS IT NO-OP?
	JZ 	NEAR EGO		;IF SO, DON'T DO ANYTHING
;* ASSIGNMENT, SET A VARIABLE'S VALUE
ASST:	CMP	AL,'='		;TEST FOR ASSIGNMENT
	JNZ 	EQUAL	;IF NOT, TRY EQUALITY
	MOV	[EFLAG],AL	;SET ASSIGNMENT FLAG
	INC	DX		;BACK UP TO VARIABLE NAME
	MOV	BP,DX
	MOV	AL,[BP]		;GET VARIABLE CHARACTER
	CMP	AL,']'		;TEST FOR ARRAY STORAGE
	JZ 	ASTOR		;IF SO, STORE INTO ARRAY
	;MOV 	BH,CH		;GET OLD VALUE
	;MOV 	BL,CL		;INTO H-L [WHERE STORE WANTS THEM]
	MOV	BX,CX
	CMP	AL,'?'		;TEST FOR SETTING RANDOM SEED
	JZ 	SRSEED	;IF SO, SET THE SEED
	CALL	STOR		;STORE VALUE INTO VARIABLE
STRT:
 	DEC	DX		;STEP BACK FROM VARIABLE
	JMP	EGO		;AND CONTINUE
;* SET THE RANDOM SEED
SRSEED:	MOV	[SEED],BX	;SO WE CAN STORE IN SEED
	JMP	STRT		;AND CONTINUE
;* SET THE VALUE OF AN ARRAY ELEMENT
ASTOR:	PUSH	BX		;SAVE H-L
	CALL	DOEXP		;CALCULATE INDEX VALUE
	DEC	DX		;BACK UP PAST '['
	MOV	BP,DX
	MOV	AL,[BP]		;GET ARRAY NAME
	CALL	LOOKT		;LOOK UP IT'S ADDRESS IN THE TABLE
	MOV	CX,BX
	;MOV 	CH,BH		;GET ARRAY ADDRESS
	;MOV 	CL,BL		;INTO B-C
	POP	BX		;RERSTORE H-L
	MOV	BP,DX
	MOV	AL,[BP]		;GET ARRAY NAME BACK
	CMP	AL,'@'		;TEST FOR 'MAGIC', MEMORY REFERENCE
	JZ 	STMEM		;IF SO, SET MEMORY LOCATION
	MOV 	AL,BH		;GET HIGH BYTE OF VALUE
	MOV	BP,CX
	MOV	[BP],AL		;STASH IN ARRAY
	INC	CX		;POINT TO NEXT
STMEM:	MOV 	AL,BL		;GET LOW BYTE OF VALUE
	MOV	BP,CX
	MOV	[BP],AL		;STASH IN ARRAY
	JMP	STRT		;CONTINUE
;* TEST FOR EQUALITY.  ('==')
EQUAL:	SUB	AL,$081		;IS A '=='?
	JNZ 	GEQL		;IF NOT, TRY GREATER OR EQUAL
	CMP	BX,CX		;COMPARE OLD AND NEW
	JZ 	EG1		;TRUE IF EQUAL
	JMP	EGZ		;FALSE IF NOT EQUAL
;* GREATER OR EQUAL.  ('>=')
GEQL:	DEC	AL		;TEST FOR '>='?
	JNZ 	LEQL		;NO, TRY LESS OR EQUAL
	CMP	BX,CX		;COMPARE OLD AND NEW
	JC 	EGZ		;FALSE IF LESS THAN
	JMP	EG1		;TRUE IF GREATER OR EQUAL
;* LESS OR EQUAL.  ('<=')
LEQL:	DEC	AL		;TEST FOR '<='?
	JNZ 	NEQL		;IF NOT, TRY NOT EQUAL
	CMP	BX,CX		;COMPARE OLD AND NEW
	JZ 	EG1		;TRUE IF SAME
	JC 	EG1		;TRUE IF LESS THAN
	JMP	EGZ		;FALSE OTHERWISE

;* TEST FOR NOT EQUAL.  ('-=')
NEQL:	DEC	AL		;IS IT '-='?
	JNZ 	SYNT		;BEATS ME WHAT IT IS!
	CMP	BX,CX		;COMPARE OLD AND NEW
	JZ 	EGZ		;IF SAME, FALSE
;* RETURN RESULT OF ONE
EG1:	MOV	BX,1		;SET RESULT TO ONE
	JMP	EGO		;PASS ON RESULT
;* RETURN RESULT OF ZERO
EGZ:	MOV	BX,0		;SET RESULT TO ZERO
;* END OF OPERATION, GET NEXT OPERATOR

EGO:	CALL	FE		;GET NEXT CHARACTER
	JZ	L86L31		;IF WE PASS BEGINNING OF EXPRESSION, QUIT
	CMP	AL,'('		;ARE WE RETURNING FROM A NEST?
	JZ	L86L31		;IF SO, BACK UP ONE LEVEL
	CMP	AL,'['		;FINISHED AN ARRAY INDEX EVALUATION?
	JZ	L86L31		;RETURN TO MAIN EXPRESSION
	CMP	AL,'='		;IF IT A MULTI-CHARACTER OPERATOR
	JNZ 	EGO1		;IF NOT, DON'T PRE-EVALUATE
	DEC	DX		;BACK UP TO PRECEDING CHARACTER
	MOV	BP,DX
	MOV	AL,[BP]		;GET PRECEDING CHARACTER
	CMP	AL,'='		;IS IT '=='?
	MOV 	CH,$081		;SET UNIQUE CODE
	JZ 	EGO2		;IF '==' THEN WE HAVE IT
	INC	CH		;NEXT UNIQUE CODE
	CMP	AL,'>'		;IS IT '>='?
	JZ 	EGO2		;IF SO, WE HAVE IT
	INC	CH		;NEXT UNIQUE CODE
	CMP	AL,'<'		;IS IT '<='?
	JZ 	EGO2		;IF SO, WE HAVE IT
	INC	CH		;NEXT UNIQUE CODE
	CMP	AL,'-'		;IS IT '-='?
	JZ 	EGO2		;IF SO, WE HAVE IT
	INC	DX		;WASN'T A TWO CHARACTER OPERATOR. BACK UP
	MOV 	AL,'='		;MUST HAVE BEEN A SIMPLE '='
	JMP	EGO1		;CONTINUE EVALUATING EXPRESSION
EGO2:	MOV 	AL,CH		;SET OPERATOR TO OUR UNIQUE CODE
	JMP	EGO1		;AND CONTINUE EVALUATING EXPRESSION
;* FINDS NEXT CHARACTER IN EXPRESSION, SETS Z FLAG IF WE PASS THE BEGINNING
FE:	MOV	AL,[P]		;GET ADDRESS OF BEGINNING OF LINE
	CMP	AL,DL		;ARE WE THERE??
	JZ	L86L31		;IF SO, WE ARE FINISHED
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,' '		;IS A [USELESS] BLANK?
	JNZ	L86L31		;IF NOT, WE ARE FINISHED
	DEC	DX		;BACK UP ANOTHER CHARACTER
	JMP	FE		;AND TRY AGAIN

L86L31:	RET

;* CALCULATE A PSEUDO-RANDOM VALUE
RANDR:	MOV	BX,[SEED]		;GET RANDOM SEED
	MOV 	AL,BH		;GET HIGH BYTE OF SEED
	AND	AL,$0F7		;AND WITH HIGH MASK
	LAHF
	PUSH	AX		;SAVE PARITY FLAG
	MOV 	AL,BL		;GET LOW BYTE OF SEED
	AND	AL,$042		;AND WITH LOW BYTE OF MASK
	LAHF
	PUSH	AX		;SAVE PARITY FLAG
	POP	CX		;GET FLAGS IN C
	MOV 	AL,CL		;COPY TO A
	POP	CX		;GET FIRST SET OF FLAGS IN C
	XOR	AL,CL		;COMPUTE PARITY FOR ENTIRE WORD
	ROR	AL,3
	;ROR	AL,1		;	MOVE COMPUTED
	;ROR	AL,1		;	PARITY INTO
	;ROR	AL,1		;	THE CARRY FLAG
	CMC		;	COMP, SO SHIFT IN 1 IF EVEN
	MOV 	AL,BL		;GET LOW BYTE OF SEED
	RCL	AL,1		;	SHIFT IN CARRY, OUT HIGH BIT
	MOV 	BL,AL		;RESAVE
	MOV 	AL,BH		;GET HIGH BYTE OF SEED
	RCL	AL,1		;	SHIFT IN CARRY (HIGH BIT OF OLD LOWER)
	MOV 	BH,AL		;RESAVE
	MOV	[SEED],BX		;RESULT IS NEW SEED
	JMP	DCLB		;KEEP GOING
;*
;* EVALUATES A CHARACTER EXPRESSION
;*
CEXP:	CALL	CLBF		;CLEAR EXTRA BUFFER
	INC	DX		;SKIP TO END OF EXPRESSION
	MOV 	AL,'+'		;TO BEGIN, CONCATENATE A NULL STRING
CG1:
 	PUSH	AX		;STACK THE OPERATOR FOR LATER
	CALL	PUSHB		;COPY NEW BUFFER INTO OLD BUFFER
	CALL	CLBF		;CLEAR THE NEW BUFFER
	DEC	DX		;BACK UP IN SOURCE
	CALL	FE		;GET CHARACTER AND TEST FOR END
	CMP	AL,$22		;TEST FOR QUOTE
	JZ 	CQ		;IF SO, HANDLE QUOTED STRING
	CMP	AL,'$'		;TEST FOR CHARACTER VARIABLE
	JNZ 	SYNT		;IF NOT, IT'S NOT ANYTHING I RECOGNISE
CV:
 	DEC	DX		;BACK UP PAST DOLLAR SIGN
	MOV	BP,DX
	MOV	AL,[BP]		;GET VARIABLE NAME
	CMP	AL,']'		;TEST FOR INDEX INTO CHARACTER VARIABLE
	JZ 	NEAR CINDX		;GET INDEX VALUE
	CALL	LTA		;GET ADDRESS OF VARIABLE
	PUSH	DX		;SAVE SOURCE POSITION
	XCHG	DX,BX		;SWAP ADDRESS TO D-E
	DEC	DX		;BACK UP IN SOURCE
	JMP	Q0		;SAVE VARIABLE IN NEW BUFFER
;* BACKUP TO PRECEDING QUOTE
CQ:
 	DEC	DX		;BACKUP IN SOURCE
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER FROM SOURCE
	CMP	AL,$0D		;TEST FOR END OF LINE
	JZ 	SYNT		;IF SO, THERE IS NO CLOSEING QUOTE
	CMP	AL,$22		;TEST FOR CLOSEING QUOTE
	JNZ 	CQ		;IF NO, KEEP LOOKING
;--------------------
	;PUSH	DX		;SAVE ENDING POSITION
	
Q0:	MOV	BX,XBF		;GET ADDRESS OF NEW [EXTRA] BUFFER
	mov	bp,dx
Q1:
 	;INC	DX		;ADVANCE TO SOURCE OR VARIABLE CHARACTER
	;MOV	BP,DX
	inc	bp
	MOV	AL,[BP]		;GET CHARACTER
	CMP	AL,$22		;TEST FOR CLOSEING QUOTE
	JZ 	Q2		;IF SO, STOP COPYING
	CMP	AL,$0FF		;TEST FOR END OF VARIABLE
	JZ 	Q2		;IF SO, STOP COPYING
	MOV 	[BX],AL		;SAVE IN BUFFER
	INC	BX		;ADVANCE IN BUFFER
	JMP	Q1		;KEEP COPYING
Q2:	;POP	DX		;GET POSITION BACK
;--------------------
Q3:
 	DEC	DX		;BACK UP TO OPERATOR
	POP	AX		;GET OPERATOR
	CMP	AL,'+'		;TEST FOR CONCATENATION
	JNZ 	Q5		;NO, TRY ASSIGNMENT

;* CONCATENATION. XBF=XBF+TB
QPP:	MOV	CX,TB		;ADDRESS OF TEMPORARY BUFFER
Q4:
	MOV	BP,CX
 	MOV	AL,[BP]		;GET CHARACTER FROM BUFFER
	MOV 	[BX],AL		;MOVE TO BUFFER
	INC	CX		;ADVANCE IN OLD
	INC	BX		;ADVANCE IN NEW
	MOV 	AL,CL		;GET ADDRESS IN OLD
	CMP	AL,TB+35	;TEST FOR OVER
	JC 	Q4		;IF SO, STOP
	MOV	BL,[XBF]	;GET CHARACTER FROM BUFFER
	MOV 	BH,0		;SET HIGH BYTE TO ZERO
	JMP	Q9		;CONTINUE
;* ASSIGNMENT
Q5:	CMP	AL,'='		;TEST FOR ASSIGNMENT
	JNZ 	Q6		;IF NOT, TRY EQUALITY
	INC	DX		;SKIP TO VARIABLE NAME
	INC	DX		;SKIP TO DOLLARSIGN
	MOV	BP,DX
	MOV	AL,[BP]		;GET DOLLARSIGN
	DEC	DX		;BACK UP TO VARIABLE NAME
	CMP	AL,'$'		;TEST FOR DOLLAR SIGN
	JNZ 	SYNT		;IF NOT, THIS AIN'T NO CHARACTER VARIABLE
	MOV	[EFLAG],AL		;SET ASSIGNMENT FLAG
	MOV	BP,DX
	MOV	AL,[BP]		;GET VARIABLE NAME
	DEC	DX		;BACK UP BAST NAME
	CALL	LTA		;GET IT'S ADDRESS
	JMP	QPP		;COPY IT OVER
;* TEST FOR EQUALITY
Q6:	CMP	AL,$081		;TEST FOR '=='
	JNZ 	X0		;NO, TRY '=-'
	CALL	COMSTR		;COMPARE STRINGS
	JMP	Q9		;CONTINUE
;* COMPARES STRINGS. SETS H-L TO 1 OR 0 IF EQUAL OR NOT EQUAL
COMSTR:	MOV	CX,TB		;GET ADDRESS OF OLD STRING
	MOV	BX,XBF		;ADDRESS OF NEW STRING
Q7:
	MOV	BP,CX
 	MOV	AL,[BP]		;GET CHARACTER FROM OLD
	CMP	AL,[BX]		;TEST AGAINST NEW
	JNZ 	Q8		;IF NOT, THEY ARE UNEQUAL
	INC	CX		;NEXT PLACE IN OLD
	INC	BX		;NEXT PLACE IN NEW
	INC	AL		;TEST FOR END OF STRING
	JNZ 	Q7		;IF NOT, CONTINUE TESTING
	MOV	BX,1		;INDICATE THEY ARE EQUAL
	RET
Q8:	MOV	BX,0		;INDICATE NOT EQUAL
	RET
;* NOT EQUAL .. '-='
X0:	CMP	AL,$082		;TEST FOR '-='
	JNZ 	SYNT		;BEATS ME, BUT IT ISN'T RIGHT
	CALL	COMSTR		;TEST STRINGS
	MOV 	AL,BL		;GET RESULT
	XOR	AL,1		;AND COMPLEMENT IT
	MOV 	BL,AL		;REPLACE IN RESULT
;* GET NEXT STRING
Q9:	CALL	FE		;GET NEXT CHARACTER
	STC			;INDICATE CHARACTER EXPRESSION
	JZ	L86L36		;IF END OF LINE, QUIT
	CMP	AL,'('		;TEST FOR END OF NUMERIC SUBSTRING
	JZ	L86L36		;QUIT, INDICATING NUMBERIC RESULT
	CMP	AL,'='		;TEST FOR EQUAL,ASSIGNMENT, OR NOT EQUALS
	JNZ 	CG1		;NO, NO NEED TO TEST FURTHER
QTST:
 	DEC	DX		;BACK UP TO PREVIOUS CHARACTER
	MOV	BP,DX
	MOV	AL,[BP]		;GET CHARACTER
	MOV 	CH,AL		;SAVE FOR COMPARISON
	CMP	AL,'='		;TEST FOR '=='
	MOV 	AL,$081		;INDICATE '=='
	JZ 	CG1		;CONTINUE
	MOV 	AL,CH		;GET CHARACTER BACK
	CMP	AL,'-'		;TEST FOR '-='
	MOV 	AL,$082		;INDICATE '-='
	JZ 	CG1		;CONTINUE
	INC	DX		;ADVANCE BACK TO PREVIOUS CHARACTER
	MOV 	AL,'='		;INDICATE '='
	JMP	CG1		;CONTINUE
;* CLEARS THE TEXT BUFFER
CLBF:	MOV	BX,XBF		;GET ADDRESS OF BUFFER
	MOV 	AL,40		;CLEAR FOR LENGTH OF 40
CL2:	MOV 	byte [BX],$0FF		;CLEAR TO NULL CHARACTER
	INC	BX		;NEXT POSITION IN BUFFER
	DEC	AL		;REDUCE COUNT OF REMAINING
	JNZ 	CL2		;KEEP GOING TILL WE ARE FINISHED
L86L36:
	RET
;* COPY'S NEW BUFFER INTO OLD BUFFER
PUSHB:	PUSH	DX		;SAVE POSITION IS SOURCE
	MOV	DX,XBF		;GET ADDRESS OF NEW BUFFER
	MOV	BX,TB		;GET ADDRESS OF OLD BUFFER
	MOV 	CH,40		;COPY 40 CHARACTERS
PU1:
	MOV	BP,DX
 	MOV	AL,[BP]		;GET CHARACTER FROM NEW
	MOV 	[BX],AL		;SAVE IN OLD
	INC	BX		;NEXT POSITION IN OLD
	INC	DX		;NEXT POSITION IN NEW
	DEC	CH		;REDUCE COUNT
	JNZ 	PU1		;KEEP GOING TILL 40 ARE MOVED
	POP	DX		;RESTORE POSITION IN SOURCE
	RET
;* INDEXED CHARACTER VARIABLE, EXTRACT A SINGLE CHARACTER
CINDX:	CALL	DOEXP		;EVALUATE INDEX EXPRESSION
	MOV 	AL,BL		;GET INDEX VALUE
	PUSH	AX		;SAVE INDEX VALUE
	DEC	DX		;BACK UP TO VARIABLE NAME
	MOV	BP,DX
	MOV	AL,[BP]		;GET VARIABLE NAME
	CMP	AL,'@'		;TEST FOR 'MAGIC' CHR$ VARIABLE
	JZ 	CHR		;IF SO, HANDLE SPECIAL CASE
	CALL	LTA		;GET TEXT VARIABLE ADDRESS
	POP	AX		;GET INDEX BACK
	CMP	AL,35		;TEST FOR TOO BIG
	JNC 	DIMERR		;IF SO, TELL HIM HE SCREWED UP
	MOV 	CL,AL		;GET INTO A DOUBLE PAIR
	ADD	BX,CX		;SO WE CAN DAD IT TO THE ADDRESS
	MOV 	AL,[BX]		;AND GET THE CHARACTER
FILBUF:	MOV	BX,XBF		;ADDRESS OF TEXT BUFFER
	MOV 	[BX],AL		;PLACE CHARACTER THERE
	INC	BX		;BUMP TO NEXT POSITION
	JMP	Q3		;AND FILL WITH NULLS
;*
;* 'MAGIC' CHARACTER ARRAY, RETURNS CHARACTER WITH VALUE OF IT'S INDEX
;*
CHR:	POP	AX		;GET INDEX VALUE
	SAHF
	JMP	FILBUF		;SAVE IN BUFFER AND PAD WITH NULLS




;* END OF BASIC INTERPRETER CODE SECTION

;*
;**********************************************************************
;*                          COMMAND TABLE
;*
;*   FORMAT IS:
;*               COMMAND WORDS, HIGH BIT SET ON LAST CHARACTER
;*               ADDRESS OF COMMAND PROCESSOR FOLLOWES
;*               ENTRY OF HEX 00 INDICATES LAST ENTRY IN TABLE (DEFAULT)
;*
;**********************************************************************
;*
;* COMMANDS ALLOWED ONLY FROM WITHING A PROGRAM..
PTAB:	db	"NEX"
	db	'T'+$80
	dw	NEXT
	db	"THE"
	db	'N'+$80
	dw	THEN
	db	"GOSU"
	db	'B'+$80
	dw	GOSUB
	db	"RETUR"
	db	'N'+$80
	dw	RETURN
	db	"FO"
	db	'R'+$80
	dw	FOR
	db	"I"
	db	'F'+$80
	dw	IF
DATCMD:	db	"DAT"
	db	'A'+$80
	dw	RNEXT
	db	"LI"
	db	'F'+$80
	dw	LIF
;* COMMANDS ALLOWED FROM BOTH A PROGRAM, AND INTERACTIVE KEYBOARD ENTRY
KTAB:	db	"GOT"
	db	'O'+$80
	dw	GOTO
	db	"LE"
	db	'T'+$80
	dw	LET
	db	"PRIN"
	db	'T'+$80
	dw	PRINT
;	db	"US"
;	db	'R'+$80
;	dw	USR
	db	"REA"
	db	'D'+$80
	dw	READ
	db	"PLO"
	db	'T'+$80
	dw	PLOT
	db	"RE"
	db	'M'+$80
	dw	REM
	db	"DI"
	db	'M'+$80
	dw	DIM
	db	"RU"
	db	'N'+$80
	dw	RUN
	db	"ORDE"
	db	'R'+$80
	dw	ORDER
	db	"INPU"
	db	'T'+$80
	dw	INPUT
	db	"CLEA"
	db	'R'+$80
	dw	CLEAR
	db	"STO"
	db	'P'+$80
	dw	STOP
	db	"EN"
	db	'D'+$80
	dw	INIT
	db	"LIS"
	db	'T'+$80
	dw	LIST
	db	"NE"
	db	'W'+$80
	dw	NEW
	db	"SIZ"
	db	'E'+$80
	dw	SIZE
	db	"LOA"
	db	'D'+$80
	dw	LOAD
	db	"SAV"
	db	'E'+$80
	dw	SAVE
	db	"EXI"
	db	'T'+$80
	dw	EXIT
	db	"VIDE"
	db	'O'+$80
	dw	VIDEO
	db	"INKE"
	db	'Y'+$80
	dw	INKEY
%ifdef EXTRA
	db	"EXE"
	db	'C'+$80
	dw	EXEC
%endif
	db	0		;UNRECOGNIZED COMMAND, ASSUME 'LET'
	dw	LET

;*
;***************************************************************
;*                    DEFMINGS AND MESSAGES
;***************************************************************
;*
;* ERROR MESSAGES..
;*
DER:	db	"DIVIDE BY ZERO",0	;DIVIDE BY ZERO
IERMS:	db	"BAD DATA - RETRY"	;BAD RESPONSE TO INPUT STATEMENT
	db	$0D
CSTK:	db	"NESTING",0		;INVALID FOR/NEXT, GOSUB/RETURN NESTING
LIN:	db	"LINE NUMBER",0		;GOTO, GOSUB, OR ORDER TO UNKNOWN LINE
NP:	db	"NO PROGRAM",0		;RUN OR SAVE EMPTY PROGRAM
INL:	db	" IN LINE ",0		;INDICATES LINE ERROR WAS IN
SYN:	db	"SYNTAX",0		;DOES NOT FOLLOW SYNTAX RULES
DTXT:	db	"DATA",0		;BAD LINE OR DATA TYPE
OVM:	db	"DIMENSION",0		;TO MANY ARRAYS, ARGUMENT OUT OF RANGE
;*
;* INFORMATIONAL MESSAGES..
;*
RDY:	db	"READY"			;READY PROMPT
	db	$0D
STMSG:	db	"STOP",0		;INDICATES PROGRAM STOPPED
EM:	db	" ERROR",0		;INDICATES ERROR OCCURED
SIMSG:	db	" BYTES"		;DISPLAYED IN RESPONSE TO "SIZE"
	db	$0D

;DEFC ENDIT  =  * 



;##########################################
;##########################################

;####         MONITOR PORTION          ####

;##########################################
;##########################################


;* DISPLAYS MESSAGE ON DISPLAY UP TO A CARRIAGE-RETURN. OR ZERO
PMSG:	MOV 	AL,[BX]		;GET CHARACTER FROM MESSAGE
	AND	AL,AL		;END OF MESSAGE?
 
	JNZ	L86L38
	RET  ;			;IF SO, RETURN
L86L38:
	CALL	OUTCH		;DISPLAY IT
	INC	BX		;POINT TO NEXT CHAR. IN MESSAGE
	CMP	AL,$0D		;TEST FOR CARRIAGE RETURN
	JNZ 	PMSG		;IF NOT, KEEP DISPLAYING


;* DISPLAYS A LINE-FEED, CARRIAGE-RETURN PAIR ON THE VIDEO DISPLAY
NL:	;LD 	A,$00A		;GET LINE-FEED
	;CALL	OUTCH		;DISPLAY
	MOV 	AL,$0D		;GET CARRIAGE RETURN
	JMP	OUTCH		;DISPLAY AND RETURN


;* DISPLAYS A SPACE ON THE TERMINAL
SPACE:	MOV 	AL,' '		;GET A SPACE
	JMP	OUTCH		;DISPLAY


; **********************************************************
; ACCEPT INPUT CHARATER 
; **********************************************************
; 
; ARGUMENTS:	--	Character input is output in register A.
; 
; **********************************************************


UNGET:	dw	258

INCH:	PUSH	CX
	PUSH	DX
	PUSH	BX
	
;*************

	;mov	ah,44h	; IOCTL
	;mov	al,0	; get device information
	;mov	bx,0	; set file handle to STDIN
	;int	21h
	;and	dl,32
	;mov	ax,256
	;jnz	iseof

	MOV	BP,UNGET
	MOV	AX,[BP]
	CMP	AX,258
	JZ	NOBUF
	MOV	[BP],word 258
	JMP	iseof
NOBUF:

	;mov	ah,7
	MOV	AH,6
	MOV	DL,255
	int	21h
	mov	ah,0
	jnz	iseof
	mov	ax,256
iseof:

	

;	mov	ah,3fh	; read from file or device function
;	mov	bx,0	; set file handle to STDIN
;	mov	cx,1	; read one byte
;	mov	dx,buffin
;	int	21h
;	mov	ax,[buffin]
;	jnc	gotchar
;	mov	al,0
;	mov	[buffin],al
;	mov	ah,1

;*************
	
	POP	BX
	POP	DX
	POP	CX

	;;cp	03h	; CTRL/C ?
	;;ret	z	; if so, exit
	RET

buffin: db 0
	db 0	; this one should remain set to zero


;*
;* TEST FOR CTRL-C FROM KEYBOARD. ALSO, IF LINE-FEED IS PRESSED,
;* THEN WAIT TILL IT IS RELEASED
;*
;CTRLC:
;	push	ax
;	or	al,1
;	pop	ax
;	ret
	
	
;	CALL    1F54h           ; call BREAK-KEY to read keyboard immediately.
;	JNC	dobreak
;	OR	AL,1		; reset zero flag
;	RET
;dobreak:
;	XOR	AL,AL		; set zero flag
;	RET




; Print char
OUTCH:
	PUSH	BX
	LAHF			; inserted by converter, we don't really need to keep flags
	PUSH	AX
	PUSH	CX
	PUSH	DX

	MOV	ah,2		;<--- Prefix for DOS BIOS function

;	cmp	al,0Ch
;	jnz	notcls
;	mov	cx,50	; max 50 lines
;	mov	al,13
;in_cls:	call	OUTCH
;	loop	in_cls
;	jp	eoutch
;notcls:

	cmp	al,13
	jnz	nocr
	mov	dl,13
	INT	21h
	mov	al,10
nocr:
	mov	dl,al		;<--- put char code in correct register for DOS BIOS function
	INT	21h		;<--- DOS BIOS

;eoutch:
	POP	DX
	POP	CX
	POP	AX
	SAHF			; inserted by converter
	POP	BX
	ret

	;;;;resb 100h

TAIL:

;########################################################################
;## APPENDING HERE THE BASIC PROGRAM AND PATCHING THE BEGINNING OF THE ##
;## INTERPRETER WILL PERMIT A NICE 'PACKAGING' FUNCTIONALITY TO MAKE A ##
;#########################  .COM PROGRAM  ###############################
;########################################################################
